<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1. JavaEE 介绍</title>
    <url>/2022/09/12/JavaEE/1.%20JavaEE%20%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="1-什么是JavaEE"><a href="#1-什么是JavaEE" class="headerlink" title="1. 什么是JavaEE"></a>1. 什么是JavaEE</h1><p>Java 包括三大板块,分别为JavaSE JavaEE JavaME 其中JavaSE为Java标准版,是别人写好的一套类库,只不过这个类库是标准类库,不管是今后学习JavaME还是JavaEE,JavaSE一定是基础,必须要先行学习,而JavaME是Java微型版,主要用于机顶盒内核程序，吸尘器内核程序，电冰箱内核程序，电饭煲内核程序,JavaEE是Java企业版,也是别人写好的一套类库，只不过这套类库可以帮助我们完成企业级项目的开发，专门为企业内部提供解决方案的一套（多套）类库。<strong>Java比较火爆的就是这个JavaEE方向。</strong></p>
<h1 id="2-关于JavaEE的版本"><a href="#2-关于JavaEE的版本" class="headerlink" title="2. 关于JavaEE的版本"></a>2. 关于JavaEE的版本</h1><ul>
<li>JavaEE目前最高版本是 JavaEE8</li>
<li>JavaEE被Oracle捐献了，Oracle将JavaEE规范捐献给Apache了。</li>
<li>Apache把JavaEE换名了，以后不叫JavaEE了，以后叫做 jakarta EE。</li>
<li>以后没有JavaEE了。以后都叫做Jakarta EE。</li>
<li>JavaEE8版本升级之后的”JavaEE 9”，不再是”JavaEE9”这个名字了，叫做JakartaEE9</li>
<li>JavaEE8的时候对应的Servlet类名是：javax.servlet.Servlet</li>
<li>JakartaEE9的时候对应的Servlet类名是：jakarta.servlet.Servlet （包名都换了）</li>
<li>如果你之前的项目还是在使用javax.servlet.Servlet，那么你的项目无法直接部署到Tomcat10+版本上。你只能部署到Tomcat9-版本上。在Tomcat9以及Tomcat9之前的版本中还是能够识别javax.servlet这个包。</li>
</ul>
<h1 id="3-关于系统架构"><a href="#3-关于系统架构" class="headerlink" title="3. 关于系统架构"></a>3. 关于系统架构</h1><p>系统架构包括什么形式？</p>
<ul>
<li>C&#x2F;S架构</li>
<li>B&#x2F;S架构</li>
</ul>
<p>C&#x2F;S架构</p>
<ul>
<li>Client &#x2F; Server（客户端 &#x2F; 服务器）</li>
</ul>
<p>B&#x2F;S架构</p>
<ul>
<li>B&#x2F;S（Browser &#x2F; Server，浏览器 &#x2F; 服务器）</li>
</ul>
<h1 id="4-IDEA创建开发JavaWeb程序"><a href="#4-IDEA创建开发JavaWeb程序" class="headerlink" title="4. IDEA创建开发JavaWeb程序"></a>4. IDEA创建开发JavaWeb程序</h1><ul>
<li><p>集成开发工具很多，其中目前使用比较多的是：</p>
<ul>
<li>IntelliJ IDEA（这个居多，IDEA在提示功能方面要强于Eclipse，也就是说IDEA使用起来比Eclipse更加智能，更好用。JetBrain公司开发的。收费的。）</li>
<li>Eclipse（这个少一些），Eclipse目前还是有团队使用，只不过处于减少的趋势，自己从事工作之后，可能会遇到。Eclipse是IBM团队开发的。Eclipse寓意是“日食”。“日食”表示将太阳吃掉。太阳是SUN。IBM团队开发Eclipse的寓意是吞并SUN公司，但是2009年的时候SUN公司被Oracle公司并购了。IBM并没有成功并购SUN公司。</li>
</ul>
</li>
<li><p>使用IDEA集成开发工具开发Servlet</p>
<ul>
<li>第一步：New Project（我比较习惯先创建一个Empty Project【空工程】，然后在空工程下新建Module【模块】，这不是必须的，只是一种习惯，你可以直接新建非空的Project），这个Empty Project起名为：javaweb（不是必须的，只是一个名字而已。一般情况下新建的Project的名字最好和目录的名字一致。）</li>
<li>第二步：新建模块（File –&gt; new –&gt; Module…）<ul>
<li>这里新建的是一个普通的JavaSE模块（这里先不要新建Java Enterprise模块）</li>
<li>这个Module自动会被放在javaweb的project下面。</li>
<li>这个Module起名：servlet01</li>
</ul>
</li>
<li>第三步：让Module变成JavaEE的模块。（让Module变成webapp的模块。符合webapp规范。符合Servlet规范的Module）<ul>
<li>在Module上点击右键：Add Framework Support…（添加框架支持）</li>
<li>在弹出的窗口中，选择Web Application（选择的是webapp的支持）</li>
<li>选择了这个webapp的支持之后，IDEA会自动给你生成一个符合Servlet规范的webpp目录结构。</li>
<li><strong>重点，需要注意的：在IDEA工具中根据Web Application模板生成的目录中有一个web目录，这个目录就代表webapp的根</strong></li>
</ul>
</li>
<li>第四步（非必须）：根据Web Application生成的资源中有index.jsp文件，这里我选择删除这个index.jsp文件。</li>
<li>第五步：编写Servlet（StudentServlet）<ul>
<li>class StudentServlet implements Servlet</li>
<li>这个时候发现Servlet.class文件没有。怎么办？将CATALINA_HOME&#x2F;lib&#x2F;servlet-api.jar和jsp-api.jar添加到classpath当中（这里的classpath说的是IDEA的classpath）<ul>
<li>File –&gt; Project Structrue –&gt; Modules –&gt; + 加号 –&gt; Add JARS….</li>
</ul>
</li>
<li>实现jakarta.servlet.Servlet接口中的5个方法。</li>
</ul>
</li>
<li>第六步：在Servlet当中的service方法中编写业务代码（我们这里连接数据库了。）</li>
<li>第七步：在WEB-INF目录下新建了一个子目录：lib（这个目录名可不能随意，必须是全部小写的lib），并且将连接数据库的驱动jar包放到lib目录下。</li>
<li>第八步：在web.xml文件中完成StudentServlet类的注册。（请求路径和Servlet之间对应起来）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;web-app xmlns=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="line">         version=<span class="string">&quot;4.0&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;com.bjpowernode.javaweb.servlet.StudentServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;studentServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/student&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<p>第九步：给一个html页面，在HTML页面中编写一个超链接，用户点击这个超链接，发送请求，Tomcat执行后台的StudentServlet。</p>
<ul>
<li><p>student.html</p>
</li>
<li><p>这个文件不能放到WEB-INF目录里面，只能放到WEB-INF目录外面。</p>
</li>
<li><p>student.html文件的内容</p>
</li>
<li><pre><code class="html">  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
      &lt;title&gt;student page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
      &lt;!--这里的项目名是 /xmm ，无法动态获取，先写死--&gt;
      &lt;a href=&quot;/xmm/servlet/student&quot;&gt;student list&lt;/a&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
</li>
<li><p>第十步：让IDEA工具去关联Tomcat服务器。关联的过程当中将webapp部署到Tomcat服务器当中。</p>
<ul>
<li>IDEA工具右上角，绿色小锤子右边有一个：Add Configuration</li>
<li>左上角加号，点击Tomcat Server –&gt; local</li>
<li>在弹出的界面中设置服务器Server的参数（基本上不用动）</li>
<li>在当前窗口中有一个Deployment（点击这个用来部署webapp），继续点击加号，部署即可。</li>
<li>修改 Application context为：&#x2F;xmm</li>
</ul>
</li>
<li><p>第十一步：启动Tomcat服务器</p>
<ul>
<li>在右上角有绿色的箭头，或者绿色的小虫子，点击这个绿色的小虫子，可以采用debug的模式启动Tomcat服务器。</li>
<li>我们开发中建议适用debug模式启动Tomcat</li>
</ul>
</li>
<li><p>第十二步：打开浏览器，在浏览器地址栏上输入：<a href="http://localhost:8080/xmm/student.html">http://localhost:8080/xmm/student.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Servlet的生命周期</title>
    <url>/2022/09/12/JavaEE/2.%20Servlet%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="1-什么是Servlet的生命周期"><a href="#1-什么是Servlet的生命周期" class="headerlink" title="1. 什么是Servlet的生命周期"></a>1. 什么是Servlet的生命周期</h1><ul>
<li>Servlet对象什么时候被创建。</li>
<li>Servlet对象什么时候被销毁。</li>
<li>Servlet对象创建了几个？</li>
<li>Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。</li>
</ul>
<h1 id="2-Servlet对象是由谁来维护的"><a href="#2-Servlet对象是由谁来维护的" class="headerlink" title="2. Servlet对象是由谁来维护的"></a>2. Servlet对象是由谁来维护的</h1><ul>
<li>Servlet对象的创建，对象上方法的调用，对象最终的销毁，Javaweb程序员是无权干预的。</li>
<li>Servlet对象的生命周期是由Tomcat服务器（WEB Server）全权负责的。</li>
<li>Tomcat服务器通常我们又称为：WEB容器。（这个叫法你要知道【WEB Container】）</li>
<li>WEB容器来管理Servlet对象的死活。</li>
</ul>
<h1 id="3-Servlet-接口的方法详解"><a href="#3-Servlet-接口的方法详解" class="headerlink" title="3. Servlet 接口的方法详解"></a>3. Servlet 接口的方法详解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无参构造方法,只会执行一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoServlet</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// init方法 只会执行一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// destroy方法 只会执行一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line"> 	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在用户第一次发送请求的时候, 便会实例化Servlet,执行无参数的构造方法</p>
</li>
<li><p>在实例化对象被创建出来之后便会执行对象中的init方法,且只会调用这一次(init 方法在执行的时候,对象已经存在了)</p>
</li>
<li><p>用户在发送请求的时候,init方法执行之后,Tomcat服务器会马上执行service方法(之后的第二次第三次第四次…请求会只执行servlet方法) <strong>这说明:</strong></p>
<ul>
<li>第一：Servlet对象是单例的（单实例的。但是要注意：Servlet对象是单实例的，但是Servlet类并不符合单例模式。我们称之为假单例。之所以单例是因为Servlet对象的创建我们javaweb程序员管不着，这个对象的创建只能是Tomcat来说了算，Tomcat只创建了一个，所以导致了单例，但是属于假单例。真单例模式，构造方法是私有化的。）</li>
<li>第二：无参数构造方法、init方法只在第一次用户发送请求的时候执行。也就是说无参数构造方法只执行一次。init方法也只被Tomcat服务器调用一次。</li>
<li>第三：只要用户发送一次请求：service方法必然会被Tomcat服务器调用一次。发送100次请求，service方法会被调用100次。</li>
</ul>
</li>
<li><p>用户在关闭服务器的时候,会执行destroy方法,且在执行destory方法时,对象还在,执行过后再销毁对象</p>
</li>
<li><p>Servlet对象更像一个人的一生：</p>
<ul>
<li>Servlet的无参数构造方法执行：标志着你出生了。</li>
<li>Servlet对象的init方法的执行：标志着你正在接受教育。</li>
<li>Servlet对象的service方法的执行：标志着你已经开始工作了，已经开始为人类提供服务了。</li>
<li>Servlet对象的destroy方法的执行：标志着临终。有什么遗言，抓紧的。要不然，来不及了。</li>
</ul>
</li>
</ul>
<p><strong>关于Servlet类中方法的调用次数？</strong></p>
<ul>
<li>构造方法只执行一次。</li>
<li>init方法只执行一次。</li>
<li>service方法：用户发送一次请求则执行一次，发送N次请求则执行N次。</li>
<li>destroy方法只执行一次。</li>
</ul>
<p><strong>当我们Servlet类中编写一个有参数的构造方法，如果没有手动编写无参数构造方法会出现什么问题？</strong></p>
<ul>
<li>报错了：500错误。</li>
<li>注意：500是一个HTTP协议的错误状态码。</li>
<li>500一般情况下是因为服务器端的Java程序出现了异常。（服务器端的错误都是500错误：服务器内部错误。）</li>
<li>如果没有无参数的构造方法，会导致出现500错误，无法实例化Servlet对象。</li>
<li>所以，一定要注意：在Servlet开发当中，不建议程序员来定义构造方法，因为定义不当，一不小心就会导致无法实例化Servlet对象。</li>
</ul>
<p><strong>思考：Servlet的无参数构造方法是在对象第一次创建的时候执行，并且只执行一次。init方法也是在对象第一次创建的时候执行，并且只执行一次。那么这个无参数构造方法可以代替掉init方法吗？</strong></p>
<ul>
<li>不能。</li>
<li>Servlet规范中有要求，作为javaweb程序员，编写Servlet类的时候，不建议手动编写构造方法，因为编写构造方法，很容易让无参数构造方法消失，这个操作可能会导致Servlet对象无法实例化。所以init方法是有存在的必要的。</li>
</ul>
<p><strong>init、service、destroy方法中使用最多的是哪个方法？</strong></p>
<ul>
<li>使用最多就是service方法，service方法是一定要实现的，因为service方法是处理用户请求的核心方法。</li>
<li>什么时候使用init方法呢？<ul>
<li>init方法很少用。</li>
<li>通常在init方法当中做初始化操作，并且这个初始化操作只需要执行一次。例如：初始化数据库连接池，初始化线程池….</li>
</ul>
</li>
<li>什么时候使用destroy方法呢？<ul>
<li>destroy方法也很少用。</li>
<li>通常在destroy方法当中，进行资源的关闭。马上对象要被销毁了，还有什么没有关闭的，抓紧时间关闭资源。还有什么资源没保存的，抓紧时间保存一下。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 手撕 GenericServlet</title>
    <url>/2022/09/12/JavaEE/3.%20%E6%89%8B%E6%92%95GenericServlet/</url>
    <content><![CDATA[<h1 id="1-为什么会出现-GenericServlet"><a href="#1-为什么会出现-GenericServlet" class="headerlink" title="1. 为什么会出现 GenericServlet"></a>1. 为什么会出现 GenericServlet</h1><p>在我们编写JavaEE程序中,每一个Servlet类都需要直接实现Servlet接口,这样我们就不许实现所有的接口方法,但是其大部分情况下我们只需要使用service方法,对于其他方法是不需要的,就会显得代码过于丑陋,所以就有了 GenericServlet。</p>
<p><strong>GenericServlet 是用来干什么的?</strong></p>
<p>为了使得每个业务都可以只实现所需要的方法,就需要GenericServlet从中间适配,就比如手机直接插到220V的电压上，手机直接就报废了。怎么办？可以找一个充电器。这个充电器就是一个适配器。手机连接适配器。适配器连接220V的电压。这样问题就解决了。</p>
<h1 id="2-如何编写GenericServlet"><a href="#2-如何编写GenericServlet" class="headerlink" title="2. 如何编写GenericServlet"></a>2. 如何编写GenericServlet</h1><p><strong>GenericServlet 的实现过程</strong></p>
<p>编写一个GenericServlet类，这个类是一个抽象类，其中有一个抽象方法service。</p>
<ul>
<li>GenericServlet实现Servlet接口。</li>
<li>GenericServlet是一个适配器。</li>
<li>以后编写的所有Servlet类继承GenericServlet，重写service方法即可。</li>
</ul>
<p><strong>GenericServlet 改造</strong></p>
<ul>
<li><p>思考第一个问题：我提供了一个GenericServlet之后，init方法还会执行吗？</p>
<ul>
<li>还会执行。会执行GenericServlet类中的init方法。</li>
</ul>
</li>
<li><p>思考第二个问题：init方法是谁调用的？</p>
<ul>
<li>Tomcat服务器调用的。</li>
</ul>
</li>
<li><p>思考第三个问题：init方法中的ServletConfig对象是谁创建的？是谁传过来的？</p>
<ul>
<li>都是Tomcat干的。</li>
<li>Tomcat服务器先创建了ServletConfig对象，然后调用init方法，将ServletConfig对象传给了init方法。</li>
</ul>
</li>
<li><p>思考一下Tomcat服务器伪代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tomcat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// Tomcat服务器伪代码</span></span><br><span class="line">        <span class="comment">// 创建LoginServlet对象（通过反射机制，调用无参数构造方法来实例化LoginServlet对象）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.bjpowernode.javaweb.servlet.LoginServlet&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        <span class="type">Servlet</span> <span class="variable">servlet</span> <span class="operator">=</span> (Servlet)obj;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建ServletConfig对象</span></span><br><span class="line">        <span class="comment">// Tomcat服务器负责将ServletConfig对象实例化出来。</span></span><br><span class="line">        <span class="comment">// 多态（Tomcat服务器完全实现了Servlet规范）</span></span><br><span class="line">        <span class="type">ServletConfig</span> <span class="variable">servletConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.catalina.core.StandardWrapperFacade();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Servlet的init方法</span></span><br><span class="line">        servlet.init(servletConfig);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Servlet的service方法</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对此改造GenericServlet:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GenericServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>, ServletConfig, Serializable &#123;</span><br><span class="line">    <span class="comment">// 将 ServletConfig 设置为成员变量,方便其其他方法和子类调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericServlet</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInitParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getServletConfig().getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServletContext <span class="title function_">getServletContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getServletConfig().getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 init 将 Tomcat 所实例化的 config 传递给 成员变量 config</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="built_in">this</span>.config = config;</span><br><span class="line">        <span class="built_in">this</span>.init(); <span class="comment">// (重点!!!) 调用下面公开的init方法,给子类重写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个公开的 init() 方法,可以允许子类重写这个方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意 :</strong>  GenericServlet 方法已经被 jakarta 实现,不需要我们自己手写,并且Oracle 已经为 GenericServlet 实现了更好的子类,我们可能在使用过程中直接调用那些子类。</p>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>1. Java 概述</title>
    <url>/2022/09/11/JavaSE/1.%20Java%20%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p><strong>程序：一系列有序指令的集合</strong></p>
</blockquote>
<h1 id="1-1-Java-历史"><a href="#1-1-Java-历史" class="headerlink" title="1.1 Java 历史"></a>1.1 Java 历史</h1><ul>
<li>Java 目前属于甲骨文公司</li>
<li>长期支持版本为Java8 和Java11(两个版本也是目前公司运用的主流版本)</li>
<li>JavaSE: 标准版本 (基础)</li>
</ul>
<p>JavaEE: 企业版本 (包含JavaWeb,是SE版本的延申)<br>JaveME: 小型版本</p>
<h1 id="1-2-Java-重要特点"><a href="#1-2-Java-重要特点" class="headerlink" title="1.2 Java 重要特点"></a>1.2 Java 重要特点</h1><ol>
<li><p>Java 语言是面向对象的语言(oop)</p>
<blockquote>
<p>简单来说，面向对象是一种程序设计技术。其重点是放在对象和对象的接口上</p>
</blockquote>
</li>
<li><p>Java 语言是健壮的</p>
<blockquote>
<p>Java 强调早期问题检测、后期动态检测，及消除易出错的情况。其编译器能检测很多其他语言仅在运行时才会发现的问题。</p>
</blockquote>
</li>
<li><p>Java 语言是跨平台性的：一个编译好的 .class 文件可以在多个不同系统下直接运行。</p>
<blockquote>
<p>Java 中没有 “依赖具体实现” 的地方。其基本数据类型大小、有关运算的行为等都有明确说明。其绝大多数库都能很好地支持平台独立性，而不用担心操作系统。</p>
</blockquote>
</li>
<li><p>Java 语言是解释型的：解释型语言编译后需要解释器才能运行。相对的，编译型语言可以被直接执行。</p>
<blockquote>
<p>Java 解释器能在任何移植了解释器的机器上直接执行 Java 字节码。</p>
</blockquote>
</li>
</ol>
<h1 id="1-3-Java的开发工具"><a href="#1-3-Java的开发工具" class="headerlink" title="1.3 Java的开发工具"></a>1.3 Java的开发工具</h1><ul>
<li><code>javac</code>：Java 编译器。将 Java 程序编译成字节码</li>
<li><code>java</code>：Java 解释器。执行已经转换为字节码的文件</li>
<li><code>jdb</code>：Java 调试器。调试 Java 程序</li>
<li><code>javap</code>：反编译。将类文件还原回方法和变量</li>
<li><code>javadoc</code>：文档生成器。创建 HTML 文件</li>
</ul>
<h1 id="1-4-Java的运行基础"><a href="#1-4-Java的运行基础" class="headerlink" title="1.4 Java的运行基础"></a>1.4 Java的运行基础</h1><h2 id="1-4-1-JDK、JRE、JVM"><a href="#1-4-1-JDK、JRE、JVM" class="headerlink" title="1.4.1 JDK、JRE、JVM"></a>1.4.1 JDK、JRE、JVM</h2><blockquote>
<p>JVM Java虚拟机</p>
</blockquote>
<ul>
<li><p>JVM 是–跨平台性的基础。被包含在 JDK 中。</p>
</li>
<li><p>不同平台有各自对应的不同 JVM</p>
</li>
<li><p>JVM 屏蔽了底层平台的区别。能做到 ”一次编译，到处运行”</p>
<blockquote>
<p>JDK 全称：Java Development Kit（Java 开发工具包）</p>
</blockquote>
</li>
<li><p>JDK &#x3D; JRE + Java 的开发工具（Java，Javac，Javadoc 等等）</p>
</li>
<li><p>给开发人员使用的，包含 JRE</p>
<blockquote>
<p>JRE：Java Runtime Enviroment（Java 运行环境）</p>
</blockquote>
</li>
<li><p>JRE &#x3D; JVM + Java SE 标准类库（Java 的核心类库）</p>
</li>
<li><p>运行一个 Java 程序的基本条件</p>
</li>
</ul>
<h2 id="1-4-2-JDK、JRE、JVM-三者之间的关系"><a href="#1-4-2-JDK、JRE、JVM-三者之间的关系" class="headerlink" title="1.4.2 JDK、JRE、JVM 三者之间的关系"></a>1.4.2 JDK、JRE、JVM 三者之间的关系</h2><blockquote>
<ol>
<li>JDK &#x3D; JRE + java 开发工具</li>
<li>JRE &#x3D; JVM + 核心类库</li>
<li>JDK:</li>
</ol>
</blockquote>
<h1 id="1-5-Java-执行流程"><a href="#1-5-Java-执行流程" class="headerlink" title="1.5 Java 执行流程"></a>1.5 Java 执行流程</h1><blockquote>
<p><code>.Java 文件</code>（源文件） — <code>javac</code>（编译）— <code>.class 文件</code>（字节码文件） —<code> java（运行）</code>— 结果**</p>
</blockquote>
<h2 id="1-5-1-Java-编译"><a href="#1-5-1-Java-编译" class="headerlink" title="1.5.1 Java 编译"></a>1.5.1 Java 编译</h2><ul>
<li>通过编译器将 Java 源文件编译成 JVM 可识别的字节码文件。字节码文件是二进制格式的，其格式是统一的。在源文件目录下使用 Javac 编译工具对 Java 文件进行编译。</li>
<li>如果没有错误将没有提示，当前目录会对应其中每一个类生成对应名称的 .class 文件，即字节码文件，也是可执行的 Java 程序。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac [选项] 源文件名.java			<span class="comment">//[] 中是可选项</span></span><br><span class="line"><span class="comment">// 例如编译HelloWord.java</span></span><br><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-5-2-Java运行"><a href="#1-5-2-Java运行" class="headerlink" title="1.5.2 Java运行"></a>1.5.2 Java运行</h2><ul>
<li>有了可执行的 Java 程序（字节码文件）</li>
<li>通过运行工具 Java.exe 对字节码文件进行执行，本质是将 .class 文件装载到 JVM 运行。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java [选项] 程序名 [参数列表]			<span class="comment">//[] 中是可选项</span></span><br><span class="line"><span class="comment">// 例如运行HelloWorld.class</span></span><br><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure>
<strong><em>注意:每次修改的源文件都需要重新编译才可以运行。</em></strong></li>
</ul>
<h1 id="1-6-第一个Java程序"><a href="#1-6-第一个Java程序" class="headerlink" title="1.6 第一个Java程序"></a>1.6 第一个Java程序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. public class Hello 表示 Hello 是一个类，是一个public共有的类</span></span><br><span class="line"><span class="comment">// 2. Hello &#123; &#125; 表示一个类的开始和结束</span></span><br><span class="line"><span class="comment">// 3. public static void main(string[] args) 表示一个主方法，也表示程序的入口</span></span><br><span class="line"><span class="comment">// 4. main() &#123; &#125; 表示方法的开始和结束</span></span><br><span class="line"><span class="comment">// 5. System.out.println(&quot;Hello World&quot;); 表示输出 &quot;Hello World&quot; 并换行</span></span><br><span class="line"><span class="comment">// 6. ; 表示语句的结束</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.print(&quot;Hello World&quot;); // 输出Hello World 但是不换行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-7-Java-相关开发细节"><a href="#1-7-Java-相关开发细节" class="headerlink" title="1.7 Java 相关开发细节"></a>1.7 Java 相关开发细节</h1><ol>
<li><strong>源文件</strong>以<code>.java </code>为扩展名，源文件的基本组成部分是<code>类（class）</code></li>
<li>Java 应用程序的<strong>执行入口</strong>是 <code>main()</code>方法。其有固定的书写格式：<code>public static void main(string[]args)&#123;…&#125;</code></li>
<li>Java 语言<code>严格区分大小写</code>。</li>
<li>Java 方法由一条条语句构成，每个语句都以<code>;</code>结束。</li>
<li>大括号<code>&#123; &#125;</code>是成对出现的，缺一不可。习惯先写<code>&#123;&#125;</code>再写代码</li>
<li>一个源文件中最多只有一个<code>public</code>类，其余类不限。</li>
<li>如果文件中包含 <code>public </code>类，则文件名必须按该类命名。</li>
<li>也可以把 <code>main()</code>方法写在<code>非 public 类</code>中，然后运行指定<code>非 public 类</code>，这样入口方法是<code>非 public 类的主方法</code>。</li>
<li>在控制台按<code>tab</code>可以实现代码补齐。按方向键<code> ↑</code> 或<code>↓</code>可以调用历史代码。<blockquote>
<p>附： <strong>(1). 文件中每出现一个类，编译后就会生成对应的class文件</strong></p>
</blockquote>
</li>
</ol>
<h1 id="1-8-Java-转义字符"><a href="#1-8-Java-转义字符" class="headerlink" title="1.8 Java 转义字符"></a>1.8 Java 转义字符</h1><ol>
<li><code>\t</code>：一个制表位，实现对齐功能</li>
<li><code>\n</code>：换行符</li>
<li><code>\\</code>：一个 \</li>
<li><code>\&quot;</code>：一个 “</li>
<li><code>\&#39;</code>：一个 ‘</li>
<li><code>\r</code>：一个回车（不是换行）</li>
<li><code>\\.</code>：一个小圆点 .</li>
<li><code>\b</code>：退格键</li>
<li><code>\u????</code>：一个具体的 Unicode 字符。其中 ???? 是 4 位 16 进制数</li>
<li><code>\???</code>：一个具体的 Unicode 字符。其中 ??? 是 3 位 8 进制数</li>
</ol>
<h1 id="1-9-初学Java常见错误"><a href="#1-9-初学Java常见错误" class="headerlink" title="1.9 初学Java常见错误"></a>1.9 初学Java常见错误</h1><ol>
<li><p><strong>找不到文件</strong></p>
<blockquote>
<p>解决方法：源文件名不存在或者写错，或者当前路径错误</p>
</blockquote>
</li>
<li><p><strong>主类名和文件名不一致</strong></p>
<blockquote>
<p>解决方法：声明为public的主类应与文件名一致，否则编译失败</p>
</blockquote>
</li>
<li><p><strong>缺少分号</strong></p>
<blockquote>
<p>解决方法：编译失败，注意错误出现的行数，再到源代码中指定位置改错。</p>
</blockquote>
</li>
<li><p><strong>其他错误</strong></p>
<blockquote>
<p>解决方法：初学者大多数的错误都是语法中的错误，所以要尝试着去看懂编译器报告的错误信息</p>
</blockquote>
</li>
</ol>
<h1 id="1-10-注释"><a href="#1-10-注释" class="headerlink" title="1.10 注释"></a>1.10 注释</h1><h2 id="1-10-1-注释类型"><a href="#1-10-1-注释类型" class="headerlink" title="1.10.1 注释类型"></a>1.10.1 注释类型</h2><ul>
<li><p><strong>单行注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一条单行注释</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>选中文字按<code>ctrl</code>+ <code>/ </code>将选中文字变为单行注释</p>
</blockquote>
</li>
<li><p><strong>多行注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*	这</span></span><br><span class="line"><span class="comment">	是一段</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">	*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>多行注释中不允许多行注释嵌套</p>
</blockquote>
</li>
<li><p><strong>文件注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@auther</span> An</span></span><br><span class="line"><span class="comment">*<span class="doctag">@version</span> 3.2.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	就是说咱可以每行开头不加星号的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-10-2-文档注释详解"><a href="#1-10-2-文档注释详解" class="headerlink" title="1.10.2 文档注释详解"></a>1.10.2 文档注释详解</h2><blockquote>
<p>文档注释的注释内容可被 JDK 中的 Javadoc 工具解析，生成一套以 HTML 形式体现的说明文档。<br>抽取注释：<code>javadoc -d 生成目录 -author -.. 文档名.java</code></p>
</blockquote>
<p>文档注释包含 <strong>标记</strong> 和紧随其后的 <strong>自由格式文本</strong>：</p>
<ul>
<li><strong>标记：</strong></li>
</ul>
<p>以 <code>@ </code>开始，如 <code>@since</code><br>下面列出了一些 <strong>通用注释：</strong></p>
<ul>
<li><p><code>@since</code>始于<strong>：创建一个</strong> 始于条目。其后文本可以是引入该特性的版本的任何描述</p>
</li>
<li><p><code>@author</code>作者**：产生一个 **作者条目。可以使用多个 @author 标记</p>
</li>
<li><p><code>@version</code>版本**：产生一个 **版本条目。这里的文本可以是对当前版本的任意描述</p>
</li>
<li><p><code>@link </code>超链接**：产生一个 **超链接，链接到 javadoc 相关部分或外部文档</p>
</li>
<li><p><code>@see</code>  <strong>引用</strong>：在<code> see also</code> 部分增加一个超链接。可以添加多个 @see 标记，但必须放在一起。这里的 引用 有以下选择：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@see</span> com.test.Example#act()</span></span><br><span class="line"><span class="comment">*<span class="doctag">@see</span> &lt;a herf=&quot;../../../../../../&quot;&gt;Melody&#x27;s Box&lt;/a&gt;</span></span><br><span class="line"><span class="comment">*<span class="doctag">@see</span> &quot;一段文本&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>只提供类、方法或变量的名字。那个场合，使用 # 来分隔类名和方法名</li>
<li><code>@see</code> 后有一个 &lt; 字符的场合，需要指定超链接。可以指向任何 URL</li>
<li><code>@see</code> 后有一个 “ 字符的场合，文本会显示在 see alse 部分</li>
</ol>
</blockquote>
</li>
<li><p><strong>自由格式文本</strong>：第一句应该是一个概要性的句子。javadoc 会自动抽取这些语句生成概要页自由格式文本中，可以使用 HTML 修饰符</p>
</li>
</ul>
<h2 id="1-10-3-文档注释的插入"><a href="#1-10-3-文档注释的插入" class="headerlink" title="1.10.3 文档注释的插入"></a>1.10.3 文档注释的插入</h2><p><code>javadoc </code>工具抽取文档注释时，会从以下位置抽取：</p>
<ul>
<li><strong>模块</strong></li>
<li><strong>包（包注释）</strong><blockquote>
<p>要想产生包注释，必须在每个包目录中添加一个单独的文件有 2 种方法：</p>
</blockquote>
<ul>
<li>提供一个名为 package-info.java 的文件。其中 只能 包含文档注释，以及后面的一个 package 语句。不能包含更多的代码或注释。</li>
<li>提供一个名为 package.html 的 HTML 文件。此时会抽取 <body>…</body> 间的所有文本</li>
</ul>
</li>
<li><strong>公共类和接口</strong>（类注释）</li>
</ul>
<p>类注释必须放在 import 语句后，类定义之前</p>
<ul>
<li><strong>公共的和受保护的字段</strong></li>
</ul>
<p>只需要对公共字段（通常是静态常量）建立文档</p>
<ul>
<li><strong>公共的和受保护的构造器和方法</strong></li>
</ul>
<p>方法注释必须放在所描述的方法之前。除了通用标记外，还能使用如下标记：</p>
<pre><code>  - @param 变量描述：该标记能给当前方法的 参数 部分添加一个条目。该描述可以占据多行。一个方法的所有 `@param` 标记必须放在一起
  - @return 返回值描述：该标记能给当前方法的 返回值 部分添加一个条目。该描述可以占据多行。
  - @throws 异常描述：该标记能给当前方法的可能抛出的 异常 添加一个条目。
</code></pre>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 枚举</title>
    <url>/2022/09/11/JavaSE/10.%20%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="10-1-枚举"><a href="#10-1-枚举" class="headerlink" title="10.1 枚举"></a>10.1 枚举</h1><p>把具体的对象一一列举出来的类，就称为 枚举类（enumeration）<br>实现方法：</p>
<ol>
<li>自定义枚举</li>
<li>enum 关键字枚举</li>
</ol>
<h2 id="10-1-1-自定义枚举"><a href="#10-1-1-自定义枚举" class="headerlink" title="10.1.1 自定义枚举"></a>10.1.1 自定义枚举</h2><ol>
<li>构造器私有化</li>
<li>去掉 <code>set</code> 方法（可保留 <code>get</code>），防止属性被修改。因为枚举对象值通常为只读</li>
<li>在类内部直接创建固定对象。使用 <code>final + static</code> 共同修饰，对象名通常全部大写。</li>
<li>枚举对象按照需要可以有多个属性</li>
</ol>
<h2 id="10-1-2-enum关键字"><a href="#10-1-2-enum关键字" class="headerlink" title="10.1.2 enum关键字"></a>10.1.2 <code>enum</code>关键字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"> RED(<span class="string">&quot;小红&quot;</span>, <span class="number">10</span>), BLUE(<span class="string">&quot;小蓝&quot;</span>, <span class="number">11</span>), YELLOW; <span class="comment">//这句话要放在前面，第三个是无参</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="title function_">Example</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">     <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>用关键字 <code>enum</code> 替代 <code>class</code></li>
<li>用 <code>常量名.(形参列表);</code> 代替创建对象（放在前面）。多个对象的场合，用 <code>,</code> 间隔。</li>
<li>如果使用 <code>enum</code> 枚举，要求将常量对象写在前面</li>
</ol>
<h3 id="10-1-2-1-使用细节"><a href="#10-1-2-1-使用细节" class="headerlink" title="10.1.2.1 使用细节"></a>10.1.2.1 使用细节</h3><ol>
<li><p>当我们用 <code>enum</code> 关键字开发一个枚举类时，默认会继承 <code>java.lang.Enum</code> 类，而且是一个 <code>final</code> 类。这样，我们就能使用 <code>Enum</code> 中的相关方法。</p>
<pre><code> **也正因为如此，`enum` 类不能继承其他类，亦不能被其它类继承不过，**

` enum` 类和其他类一样，可以实现接口。
</code></pre>
</li>
<li><p>传统的 <code>public ststic final RED(&quot;小红&quot;, 10);</code> 简化为 <code>RED(&quot;小红&quot;, 10);</code></p>
</li>
<li><p>如果使用无参构造器创建枚举对象，则 <code>实参列表</code> 和 <code>( )</code> 都能省略</p>
</li>
</ol>
<h3 id="10-1-2-2-Enum类中的常用方法"><a href="#10-1-2-2-Enum类中的常用方法" class="headerlink" title="10.1.2.2 Enum类中的常用方法"></a>10.1.2.2 <code>Enum</code>类中的常用方法</h3><ul>
<li><code>valueOf</code>：将字符串转换成枚举对象。要求字符串必须是已有的常量名，否则报异常。</li>
<li><code>values</code>：返回一个数组 <code>Example[]</code>，其中包含定义的所有枚举对象</li>
<li><code>getDeclaringClass</code>：得到枚举常量所属的 <code>class</code></li>
<li><code>name</code>：得到当前枚举常量的名称。建议优先用 <code>toString</code></li>
<li><code>ordinal</code>：输出该枚举对象的次序&#x2F;编号（从 0 开始编号。如上例 <code>BLUE.ordinal = 1</code>）</li>
<li><code>compareTo</code>：比较两个枚举常量的编号（调用常量编号 减去 传入常量编号）</li>
<li><code>clone</code>：枚举类不能 <code>clone</code>，所以，这是一个只会抛出异常的方法</li>
</ul>
<h1 id="10-2-注解"><a href="#10-2-注解" class="headerlink" title="10.2 注解"></a>10.2 注解</h1><p>注解（<code>Annotation</code>）也被称为元数据（<code>Metadata</code>）。用于修饰 包、类、方法、属性、构造器、局部变量 等数据信息<br>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息<br>在 JavaSE 中，注解的使用目的比较简单，例如 标记过时的功能，忽略警告 等。在 JavaEE 中注解占据了更重要的角色，例如用于配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。</p>
<ol>
<li>使用 <code>@Annotation</code> 时要在前面增加 <code>@</code> 符号，并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。</li>
<li>三个基本的 <code>@Annotation</code>：<ul>
<li><code>@Override</code>：限定某个方法，是 重写 父类方法。该注解只能用于方法。如果你写了该注解，编译器会替你校验，看看是不是真的 重写 了父类方法。</li>
<li><code>@Deprecated</code>：用于表示某个程序元素（类、方法等）已经过时</li>
<li><code>@SuppressWarnings()</code>：抑制编辑器警告</li>
</ul>
</li>
<li>如果发现 <code>public @interface XXX&#123;&#125;</code> 这种东西，说明是定义了一个注解类 <code>XXX</code>。这里的 <code>@interface</code> 不代表接口（<code>interface</code>）。</li>
</ol>
<h2 id="10-2-1-Override"><a href="#10-2-1-Override" class="headerlink" title="10.2.1 @Override"></a>10.2.1 <code>@Override</code></h2><ol>
<li><code>@Override</code> 表示指定重写父类的方法（从编译器层面验证），如果父类没有该方法，就报错</li>
<li>不写该注解，重写依然构成重写</li>
<li><code>@Override</code> 只能修饰方法，不能修饰其他 类、包、属性等</li>
<li>查看 <code>@Override</code> 注解源码为 <code>@Target(ElementType.METHOD)</code> 说明只能修饰方法</li>
<li><code>@Target</code> 是修饰注解的注解，称为 元注解</li>
</ol>
<h2 id="10-2-2-Deprecated"><a href="#10-2-2-Deprecated" class="headerlink" title="10.2.2 @Deprecated"></a>10.2.2 <code>@Deprecated</code></h2><ol>
<li><code>@Deprecated</code> 表示指定的某个程序元素（类、方法等）已过时</li>
<li>不推荐使用，但仍能使用</li>
<li>可以修饰方法、类、字段、包、参数<code>@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</code></li>
<li><code>@Deprecated</code> 可以做到新旧版本的兼容和过度</li>
</ol>
<h2 id="10-2-3-SuppressWarnings"><a href="#10-2-3-SuppressWarnings" class="headerlink" title="10.2.3 @SuppressWarnings()"></a>10.2.3 <code>@SuppressWarnings()</code></h2><ol>
<li>当我们不想看到警告信息时，用 <code>@SuppressWarnings()</code></li>
</ol>
<p>语法：<code>@SuppressWarnings(&#123;&quot;...&quot;&#125;)</code><br>在后面 <code>(&#123;&quot;unused&quot;, &quot;unchecked&quot;&#125;)</code> 这样写入你希望抑制的信息，以下是所有可以输入的关键字</p>
<table>
<thead>
<tr>
<th><strong>关键字</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>抑制所有警告</td>
</tr>
<tr>
<td>boxing</td>
<td>抑制与装箱&#x2F;解装箱操作相关的警告</td>
</tr>
<tr>
<td>cast</td>
<td>抑制与强制转换操作相关的警告</td>
</tr>
<tr>
<td>dep-ann</td>
<td>抑制与已弃用注释相关的警告</td>
</tr>
<tr>
<td>deprecation</td>
<td>抑制与弃用有关的警告</td>
</tr>
<tr>
<td>fallthrough</td>
<td>抑制与 switch 语句中丢失断点相关的警告</td>
</tr>
<tr>
<td>finally</td>
<td>抑制不返回的 finally 块的相关警告</td>
</tr>
<tr>
<td>hiding</td>
<td>抑制与隐藏变量的局部变量相关的警告</td>
</tr>
<tr>
<td>incomplete-switch</td>
<td>抑制与 switch 语句中缺少条目相关的警告（enum）</td>
</tr>
<tr>
<td>nls</td>
<td>抑制与 非nls 字符串字面值相关的警告</td>
</tr>
<tr>
<td>null</td>
<td>抑制相对于null分析的警告</td>
</tr>
<tr>
<td>rawtypes</td>
<td>在类参数上使用泛型时，抑制与非特定类型相关的警告</td>
</tr>
<tr>
<td>restriction</td>
<td>抑制与不推荐或禁止引用有关的警告</td>
</tr>
<tr>
<td>serial</td>
<td>抑制与可序列化类缺少serialVersionUID字段相关的警告</td>
</tr>
<tr>
<td>static-access</td>
<td>抑制与不正确的静态访问有关的警告</td>
</tr>
<tr>
<td>synthetic-access</td>
<td>抑制与未优化的内部类访问相关的警告</td>
</tr>
<tr>
<td>unchecked</td>
<td>抑制与未检查的操作相关的警告</td>
</tr>
<tr>
<td>unqualified-field-access</td>
<td>抑制与字段访问不合格相关的警告</td>
</tr>
<tr>
<td>unused</td>
<td>抑制与未使用代码相关的警告</td>
</tr>
</tbody></table>
<ol start="2">
<li><code>@SuppressWarnings</code> 的范围与你放置的位置相关。</li>
</ol>
<h2 id="10-2-4-JDK-的元注解-仅作了解"><a href="#10-2-4-JDK-的元注解-仅作了解" class="headerlink" title="10.2.4 JDK 的元注解(仅作了解)"></a>10.2.4 JDK 的元注解(仅作了解)</h2><blockquote>
<p>JDK的 元注解 是用于修饰其他注解的注解</p>
</blockquote>
<ol>
<li><p><code>@Rentention</code>：指定注解的作用范围，有三种范围 <code>SOURCE</code> <code>CLASS</code> <code>RUNTIME</code></p>
<pre><code> `@Rentention` 的三种值：
</code></pre>
<ul>
<li><code>RententionPolicy.SOURCE</code>：编译器使用后，直接丢弃这种策略的注释</li>
<li><code>RententionPolicy.CLASS</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时， JVM 不会保留注释。这是默认值</li>
<li><code>RententionPolicy.RUNTIME</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解</li>
</ul>
</li>
<li><p><code>@Target</code>：指定注解的使用范围<code>@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</code></p>
</li>
<li><p><code>@Documented</code>：指定该注解会不会在 Javadoc 体现</p>
</li>
<li><p><code>@Inherited</code>：子类会继承父类注解</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 异常</title>
    <url>/2022/09/11/JavaSE/11.%20%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常”（开发过程中的语法错误和逻辑错误不是异常）<br>这些 异常事件 可分为两类：</p>
<ul>
<li><strong>Error（错误）</strong>：Java 虚拟机无法解决的严重问题。如：JVM 系统内部错误，资源耗尽等严重情况。Error 是严重错误，程序会崩溃。</li>
<li><strong>Exception</strong>：其他因编程错误或偶然的外部因素导致的一般性问题，可以使用针对性的代码进行处理。如：空指针访问，试图读取不存在的文件，网络中断等等。Exception 又分为两大类：<ul>
<li>运行时异常（程序运行时，发生的异常）</li>
<li>编译时异常（编程时，编译器检查出的异常）</li>
</ul>
</li>
</ul>
<h1 id="11-1-异常体系图"><a href="#11-1-异常体系图" class="headerlink" title="11.1 异常体系图"></a>11.1 异常体系图</h1><p>编译异常（受检异常） 和 运行异常（非受检异常）<br>Java 源程序 ——(javac.exe)——&gt; 字节码文件 ——(java.exe)——&gt; 在内存中加载，运行类<br>编译异常↑ 运行异常↑<br><img src="https://cdn.nlark.com/yuque/0/2022/png/28255706/1657289122571-8559700f-2222-401f-8eae-ce8f4171e7ce.png#clientId=u15cc0f93-f150-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=465&id=u084e2120&margin=%5Bobject%20Object%5D&name=image.png&originHeight=465&originWidth=1669&originalType=binary&ratio=1&rotation=0&showTitle=false&size=165118&status=done&style=none&taskId=u59424144-7d63-4e7a-9590-bfc3db8a4a3&title=&width=1669" alt="image.png"><br>异常分为两大类：运行时异常 和 编译时异常</p>
<ul>
<li><p>运行时异常，编译器不要求强制处置的异常。一般是指编程的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException 类及它的子类都是运行时异常</p>
<pre><code>  对于运行时异常，可以不做处理。因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响
</code></pre>
</li>
<li><p>编译时异常，是编译器要求必须处置的异常</p>
</li>
</ul>
<h2 id="11-1-1-常见的运行时异常"><a href="#11-1-1-常见的运行时异常" class="headerlink" title="11.1.1 常见的运行时异常"></a>11.1.1 常见的运行时异常</h2><p>常见的运行时异常（RuntimeException）包括</p>
<ul>
<li>NullPointerException：空指针异常</li>
<li>ArithmeticException：数学运算异常</li>
<li>ArrayIndexOutOfBoundsException：数组下标越界异常</li>
<li>ClassCastException：类型转换异常</li>
<li>NumberFormatException：数学格式异常</li>
</ul>
<p><strong>空指针异常</strong></p>
<ul>
<li><p>当应用程序试图在需要对象的地方使用 null 时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length;					<span class="comment">//这里，出现了 空指针异常</span></span><br></pre></td></tr></table></figure>
<p><strong>数学运算异常</strong></p>
</li>
<li><p>当出现异常的运算条件时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span> / <span class="number">0</span>;					<span class="comment">//这里，出现了 数学运算异常</span></span><br></pre></td></tr></table></figure>
<p><strong>数组下标越界异常</strong></p>
</li>
<li><p>用非法索引（为负或超出范围）访问数组时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">nums[-<span class="number">50</span>] = <span class="number">100</span>;					<span class="comment">//这里，出现了 数组下标越界异常</span></span><br></pre></td></tr></table></figure>
<p><strong>类型转换异常</strong></p>
</li>
<li><p>当试图把对象强制转换为不是实例的子类时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A1</span>();</span><br><span class="line">        <span class="type">A2</span> <span class="variable">a1</span> <span class="operator">=</span> (A2)a1;				<span class="comment">//这里，出现了 类型转换异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数字格式不正确异常</strong></p>
</li>
<li><p>当应用程序试图将字符串转成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);	<span class="comment">//这里，出现了 数字格式不正确异常</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-1-2-常见的编译异常"><a href="#11-1-2-常见的编译异常" class="headerlink" title="11.1.2 常见的编译异常"></a>11.1.2 常见的编译异常</h2><p>常见的编译异常：</p>
<ul>
<li>SQLException：操作数据库时，查询表可能发生异常</li>
<li>IOException：操作文件时，发生的异常</li>
<li>FileNotFoundException：操作一个不存在的文件时，发生的异常</li>
<li>ClassNotFoundException：加载类，而该类不存在时，发生的异常</li>
<li>EOFException：操作文件，到文档末尾，发生的异常</li>
<li>IllegalArguementException：参数异常</li>
</ul>
<h1 id="11-2-异常处理"><a href="#11-2-异常处理" class="headerlink" title="11.2 异常处理"></a>11.2 异常处理</h1><p>异常发生时，对异常的处理方式。如果没有显式异常处理，默认处理方式是 throws</p>
<ul>
<li><code>try - chatch - finally</code>：程序员在代码中捕获发生的异常，自行处理</li>
<li><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理。最顶级的处理者就是 JVM</li>
</ul>
<h2 id="11-2-1-try-catch异常处理"><a href="#11-2-1-try-catch异常处理" class="headerlink" title="11.2.1 try - catch异常处理"></a>11.2.1 <code>try - catch</code>异常处理</h2><p>Java 提供 try 和 catch 块 来处理异常。try 块用于包含可能出错的代码，catch 块用于处理 try 块中的异常。可以根据需要在程序中有多个<code> try - catch</code> 块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//可疑代码</span></span><br><span class="line">	<span class="comment">//将异常生成对应的异常对象，传递给 catch 块</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	<span class="comment">//如果发生异常，执行这些代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//无论是否异常，都执行这些代码</span></span><br><span class="line">    <span class="comment">//finally 块可以不写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>快捷键：选中代码后按 ctrl + alt + T</strong></p>
</blockquote>
<h3 id="11-2-1-1-使用细节"><a href="#11-2-1-1-使用细节" class="headerlink" title="11.2.1.1 使用细节"></a>11.2.1.1 使用细节</h3><ol>
<li><p>如果异常发生了，则异常发生后面的代码块都不执行，直接进入 <code>catch</code> 块</p>
</li>
<li><p>如果异常未发生，则顺序执行 <code>try</code> 代码块，<code>catch</code> 块不执行</p>
</li>
<li><p>如果希望不管是否异常，都执行一些代码，则使用 <code>finally</code></p>
</li>
<li><p>可以有多个 <code>catch</code> 捕获不同的异常。要求 子类异常在前，父类异常在后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以进行 <code>try - finally</code> 配合使用（不写 <code>catch</code>）。这种用法相当于没有捕获异常，此时程序如果出错会直接退出。应用场景，就是写一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p>
</li>
<li><p>如果没有出现异常，执行 <code>try</code> 中所有语句，不执行<code> catch</code> 语句，最后执行<code> finally</code> 语句</p>
</li>
<li><p>如果出现异常，则<code> try</code> 块异常发生后，剩余语句不执行。之后执行 <code>catch</code> 语句，最后，执行 <code>finally</code> 语句。</p>
</li>
</ol>
<h2 id="11-2-2-throws异常处理"><a href="#11-2-2-throws异常处理" class="headerlink" title="11.2.2 throws异常处理"></a>11.2.2 <code>throws</code>异常处理</h2><p>如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由调用者负责处理<br>在方法中声明 <code>throws</code> 语句可以声明抛出异常的列表。<code>throws</code> 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metord</span><span class="params">()</span> <span class="keyword">throws</span> FileNontFoundException ,NullPointerException &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-1-使用细节"><a href="#11-2-2-1-使用细节" class="headerlink" title="11.2.2.1 使用细节"></a>11.2.2.1 使用细节</h3><ol>
<li>对于 <strong>编译异常</strong>，程序中必须处理。</li>
<li>对于 <strong>运行异常</strong>，程序中诺没有处理，默认处理是 <code>throws</code></li>
<li>子类 重写 父类方法时，子类方法抛出的异常类型必须和父类一致，或者是父类抛出异常类型的子类型。</li>
<li>如果有<code> try - catch</code> 就不必 <code>throws</code> 了</li>
</ol>
<h1 id="11-3-自定义异常"><a href="#11-3-自定义异常" class="headerlink" title="11.3 自定义异常"></a>11.3 自定义异常</h1><p>当程序中出现了某些 “错误”，但该信息并未在 <code>Throwable</code> 子类中描述处理，这时候可以自己设计异常类，用于描述该错误信息</p>
<ol>
<li>定义类：自定义异常类名，继承 <code>RuntimeException</code> 或 <code>Exception</code></li>
<li>如果继承 <code>Exception</code>，属于 编译异常。</li>
<li>如果继承 <code>RuntimeException</code>，属于 运行异常。（一般来说，选这个。这样利用了默认处理机制，更方便）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Metords</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;自定义异常&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CustomException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="11-3-1-throw和-throws"><a href="#11-3-1-throw和-throws" class="headerlink" title="11.3.1 throw和 throws"></a>11.3.1 <code>throw</code>和 <code>throws</code></h2><p>| **</p>
<p> | <strong>意义</strong> | <strong>位置</strong> | <strong>后面跟的东西</strong> |<br>| — | — | — | — |<br>| throws | 异常处理的一种方式 | 方法声明时 | 异常类型 |<br>| throw | 手动生成异常对象关键字 | 方法体中 | 异常对象 |</p>
<h3 id="11-3-2-编程小技巧"><a href="#11-3-2-编程小技巧" class="headerlink" title="11.3.2 编程小技巧"></a>11.3.2 编程小技巧</h3><p>老韩：编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。</p>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>12. 包装类</title>
    <url>/2022/09/11/JavaSE/12.%20%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="12-1-包装类"><a href="#12-1-包装类" class="headerlink" title="12.1 包装类"></a>12.1 包装类</h1><blockquote>
<p>包装类（Wrapper）：针对 八种基本数据类型 相应的 引用类型<br>有了类的特点，就可以调用类中的方法</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>基本数据类型</strong></th>
<th><strong>包装类</strong></th>
<th><strong>父类</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
<td>Object</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>Object</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>Number</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>Number</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>Number</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>Number</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>Number</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Number</td>
</tr>
<tr>
<td>void</td>
<td>Void</td>
<td>Object</td>
</tr>
</tbody></table>
<h2 id="12-1-1-装箱与拆箱"><a href="#12-1-1-装箱与拆箱" class="headerlink" title="12.1.1 装箱与拆箱"></a>12.1.1 装箱与拆箱</h2><ul>
<li><p>手动装箱与拆箱(Jdk 5 之前)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);			<span class="comment">// 手动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> Integer.valueOf(n1);		<span class="comment">// 手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();					<span class="comment">// 手动拆箱</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自动装箱与拆箱(Jdk 5 之后)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n2 = <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer3</span> <span class="operator">=</span> n2;						<span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> integer3;							<span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure>
<p>虽然可以自动装箱、拆箱，但使用 &#x3D;&#x3D; 直接比较两个包装类时，仍然是比较其地址。以下比较通常会失败：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ia</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">ib</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">System.out.print(ia == ib);					<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>但，Java 实现仍有可能使其成立。Byte、Boolean 以及 Short、Integer 中 [-128, 127] 间的值已被包装到固定的对象中。对他们的比较可以成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">ia</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">ib</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.print(ia == ib);					<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>由此可见，使用 &#x3D;&#x3D; 直接比较两个包装类会带来不确定性。尽量使用 equals 方法对包装类进行比较。<br>装箱与拆箱是 编译器 的工作。在生成可执行的字节码文件时，编译器已经插入了必要的方法调用。</p>
</li>
</ul>
<h2 id="12-1-2-包装类和String-的相互转换"><a href="#12-1-2-包装类和String-的相互转换" class="headerlink" title="12.1.2 包装类和String 的相互转换"></a>12.1.2 包装类和<code>String</code> 的相互转换</h2><ul>
<li><p>包装类转换为<code>String</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> integer + <span class="string">&quot;&quot;</span>;					<span class="comment">//方法1（自动拆箱）</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> integer.toString();			<span class="comment">//方法2（toString方法）</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(integer);		<span class="comment">//方法3（自动拆箱）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String</code>转换为包装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> Integer.parseInt(str4);	<span class="comment">//方法1（自动装箱）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4);		<span class="comment">//方法2（构造器）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-1-3-包装类的常用方法"><a href="#12-1-3-包装类的常用方法" class="headerlink" title="12.1.3 包装类的常用方法"></a>12.1.3 包装类的常用方法</h2><ul>
<li><code>Integer.MIN_VALUE</code>：返回最大值</li>
<li><code>Double.MAX_VALUE</code>：返回最小值</li>
<li><code>byteValue()、doubleValue()、floatValue()、intValue()、longValue()</code>按各种基本数据类型返回该对象的值</li>
<li><code>Character.isDigit(int)</code>：判断是不是数字</li>
<li><code>Character.isLetter(int)</code>：判断是不是字母</li>
<li><code>Character.isUpperCase(int)</code>：判断是不是大写字母</li>
<li><code>Character.isLowerCase(int)</code>：判断是不是小写字母</li>
<li><code>Characher.isWhitespace(int)</code>：判断是不是空格</li>
<li><code>Character.toUpperCase(int)</code>：转成大写字母</li>
<li><code>Character.toLowerCase(int)</code>：转成小写字母</li>
<li><code>Integer.parseInt(string)</code>：将 <code>String</code> 内容转为 <code>intDouble.parseDouble(string)</code></li>
<li><code>Integer.toBinaryString(int)</code>：将数字转为 2 进制表示的字符串</li>
<li><code>Integer.toHexString(int)</code>：将数字转为 16 进制表示的字符串</li>
<li><code>Integer.toOctalString(int)</code>：将数字转为 8 进制表示的字符串特别地，浮点数类型的包装类只有转成 16 进制的方法。而 Short、Byte 及其他包装类无此方法</li>
<li><code>int Integer.bitCount(i int)</code>：统计指定数字的二进制格式中 1 的数量</li>
</ul>
<h2 id="12-1-4-strictfp-关键字"><a href="#12-1-4-strictfp-关键字" class="headerlink" title="12.1.4 strictfp 关键字"></a>12.1.4 <code>strictfp</code> 关键字</h2><blockquote>
<p>由于不同处理器对于浮点数寄存采取不同策略（有些处理器使用 64 位寄存 double，有些则是 80 位），对于浮点数的运算在不同平台上可能出现不同结果。</p>
</blockquote>
<p>使用 strictfp 关键字标记的方法或类中，所有指令都会使用严格统一的浮点数运算。比如，把 main 方法标记为 strictfp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> ᓚᘏᗢ = <span class="number">1</span> / <span class="number">13.97</span>;</span><br><span class="line">    System.out.println(ᓚᘏᗢ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="12-2-String-类"><a href="#12-2-String-类" class="headerlink" title="12.2 String 类"></a>12.2 <code>String</code> 类</h1><ol>
<li><code>String</code> 对象用于保存字符串，也就是一组字符序列</li>
<li>字符串常量对象是用双引号扩起的字符序列。例如 “你好”</li>
<li>字符串的字符使用 Unicode 字符编码。一个字符（不论字母汉字）占 2 字节</li>
<li>常用构造器：<ul>
<li><code>String str1 = new String();</code></li>
<li><code>String str2 = new String(String original);</code></li>
<li><code>String str3 = new String(char[] a);</code></li>
<li><code>String str4 = new String(char[] a, int startIndex, int count);</code>这句意思是：<code>char[]</code> 从 <code>startIndex</code> 起的 <code>count</code> 个字符</li>
</ul>
</li>
<li><code>String</code> 实现了接口 <code>Serializable</code> 和 <code>Comparable</code> ，可以 串行化和 比较大小串行化：即，可以被网络传输，也能保存到文件</li>
<li><code>String</code> 是<code>final</code> 类，不能被继承</li>
<li><code>String</code> 有属性 <code>private final char[] value;</code> 用于存放字符串内容。<code>value</code> 是 <code>final</code> 属性。其在栈中的地址不能修改，但堆中的内容可以修改。</li>
</ol>
<h2 id="12-2-1-String构造方法"><a href="#12-2-1-String构造方法" class="headerlink" title="12.2.1 String构造方法"></a>12.2.1 <code>String</code>构造方法</h2><ul>
<li><p>直接指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>该方法：先从常量池看是否有 “test” 数据空间。有的场合，指向那个空间；否则重新创建然后指向。<br>这个方法，str1 指向 常量池中的地址。</p>
</li>
<li><p>构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test02&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>该方法：先在堆中创建空间，里面维护一个 <code>value</code> 属性，指向 或 创建后指向 常量池的 “test02” 空间。<br>这个方法，str2 指向 堆中的地址</p>
</li>
</ul>
<h2 id="12-2-2-字符串的特性"><a href="#12-2-2-字符串的特性" class="headerlink" title="12.2.2 字符串的特性"></a>12.2.2 字符串的特性</h2><ul>
<li><p>常量相加，看的是池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span> + <span class="string">&quot;bb&quot;</span>;				<span class="comment">//常量相加，看的是池</span></span><br><span class="line"><span class="comment">//上例由于构造器自身优化，相当于 String str1 = &quot;aabb&quot;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>变量相加，是在堆中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> a + b;					<span class="comment">//变量相加，是在堆中</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-2-3-String的常用方法"><a href="#12-2-3-String的常用方法" class="headerlink" title="12.2.3 String的常用方法"></a>12.2.3 <code>String</code>的常用方法</h2><p>以下方法不需死记硬背，手熟自然牢记</p>
<ul>
<li>boolean equals(String s)：区分大小写，判断内容是否相等boolean equalsIgnoreCase(String s)：判断内容是否相等（忽略大小写）</li>
<li>boolean empty()：返回是否为空</li>
<li>int charAt(int index)：获取某索引处的字符（代码单元）。必须用 char c &#x3D; str.charAt(15);，不能用 char c &#x3D; str[15];</li>
<li>int codePointAt(int index)int length()：获取字符（代码单元）的个数</li>
<li>IntStream codePoints()：返回字符串中全部码点构成的流</li>
<li>long codePoints().count()：返回真正长度（码点数量）</li>
<li>int indexOf(String str)：获取字符（串）在字符串中第一次出现的索引。如果找不到，返回 -1</li>
<li>int indexOf(int char) 参数也可以传入一个 int。由于自动类型转换的存在，也能填入 </li>
<li>charint indexOf(String str, int index)：从 index 处（包含）开始查找指定字符（串）</li>
<li>int lastIndexOf(String str)：获取字符在字符串中最后一次出现的索引。如果找不到，返回 -1</li>
<li>String substring(int start, int end)：返回截取指定范围 [start, end) 的 新 字符串</li>
<li>String substring(int index)：截取 index（包含）之后的部分</li>
<li>String trim()：返回去前后空格的新字符串</li>
<li>String toUperCase()：返回字母全部转为大写的新字符串</li>
<li>String toLowerCase()：返回字母全部转为小写的新字符串</li>
<li>String concat(String another)：返回拼接字符串</li>
<li>String replace(char oldChar, char newChar)：替换字符串中的元素String str1 &#x3D; “Foolish cultists”; String str2 &#x3D; str1.replace(“cultists”, “believers”);	&#x2F;&#x2F;str1不变，str2为改变的值JAVA</li>
<li>String[] split(String regex)：分割字符串。对于某些分割字符，我们需要转义</li>
<li>int compareTo(String another)：按照字典顺序比较两个字符串（的大小）。返回出现第一处不同的字符的编号差。前面字符相同，长度不同的场合，返回那个长度差。S</li>
<li>char[] toCharArray()：转换成字符数组byte[] getBytes()：字符串转为字节数组</li>
<li>String String.format(String format, Object… args)：（静态方法）格式字符串String name &#x3D; “Roin”; String age &#x3D; “1M”; String state &#x3D; “computer”; String formatStr &#x3D; “I am %s, I am %s old, I am a %s”; String str &#x3D; String.format(formatStr, name, age, state); &#x2F;&#x2F;其中 %s 是占位符。此时，str &#x3D; “I am Roin, I am 1M old, I am a computer”; &#x2F;&#x2F;%s 表示字符串替换；%d 表示整数替换；#.2f 表示小数（四舍五入保留2位）替换；%c 表示字符替换JAVA</li>
<li>String join(deli, ele…)：拼接字符串（ele…），以 deli 间隔。</li>
<li>boolean startsWith(str)：测试 str 是否为当前字符串的前缀</li>
<li>String repeat(int n)：返回该字符串重复 n 次的结果</li>
</ul>
<h1 id="12-3-StringBuffer类"><a href="#12-3-StringBuffer类" class="headerlink" title="12.3 StringBuffer类"></a>12.3 <code>StringBuffer</code>类</h1><p><code>java.lang.StringBuffer</code> 代表可变的字符序列。可以对字符串内容进行增删。<br>很多方法和 <code>String</code> 相同，但 <code>StringBuffer</code> 是可变长度。同时，<code>StringBuffer</code> 是一个容器</p>
<ol>
<li><code>StringBuffer</code> 的直接父类是<code> AbstractStringBuffer</code></li>
<li><code>StringBuffer</code> 实现了 <code>Serialiazable</code>，可以串行化</li>
<li>在父类中，<code>AbstractStringBuffer</code> 有属性 <code>char[] value</code> 不是<code>final</code></li>
<li><code>StringBuffer</code> 是一个 <code>final</code> 类，不能被继承</li>
</ol>
<p><code>String</code> 对比 <code>StringBuffer</code></p>
<ul>
<li><code>String</code> 保存字符串常量，其中的值不能更改。每次更新实际上是更改地址，效率较低</li>
<li><code>StringBuffer</code> 保存字符串变量，里面的值可以更改。每次更新是更新内容，不用每次更新地址。</li>
</ul>
<h2 id="12-3-1-StringBuffer-构造方法"><a href="#12-3-1-StringBuffer-构造方法" class="headerlink" title="12.3.1 StringBuffer 构造方法"></a>12.3.1 <code>StringBuffer</code> 构造方法</h2><ol>
<li><p>无参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创造一个16位容量的空<code>StringBuffer</code></p>
</blockquote>
</li>
<li><p>传入字符串构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcabc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定容器构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-3-2-String-和-StringBuffer的转换"><a href="#12-3-2-String-和-StringBuffer的转换" class="headerlink" title="12.3.2 String 和 StringBuffer的转换"></a>12.3.2 <code>String</code> 和 <code>StringBuffer</code>的转换</h2><ol>
<li><p>转 <code>StringBuffer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcabc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);	<span class="comment">//方法1（构造器）</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">strb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();		</span><br><span class="line">strb1 = strb1.append(str1);						<span class="comment">//方法2（先空再append）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转 <code>String</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> strb1.toString();					<span class="comment">//方法1（toString）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(strb1);				<span class="comment">//方法2（构造器）</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="12-3-3-StringBuffer的常用方法"><a href="#12-3-3-StringBuffer的常用方法" class="headerlink" title="12.3.3 StringBuffer的常用方法"></a>12.3.3 <code>StringBuffer</code>的常用方法</h2><ul>
<li><code>append(char c)</code>：增加</li>
<li><code>append(String s)</code> 参数也能是字符串特别的，append(null); 的场合，等同于 append(“null”);</li>
<li><code>delete(start, end)</code>：删减 [start, end) 的内容</li>
<li><code>replace(start, end, string)</code>：将 start 与 end 间的内容替换为 string</li>
<li><code>indexOf</code>：查找指定字符串第一次出现时的索引。没找到的场合返回 -1</li>
<li><code>insert</code>：在指定索引位置之前插入指定字符串</li>
<li><code>length()</code>：返回字符长度</li>
<li><code>capacity()</code>：返回当前的容量String 类对象分配内存时，按照对象中所含字符个数等量分配。StringBuffer 类对象分配内存时，除去字符所占空间外，会另加 16 字符大小的缓冲区。对于 length() 方法，返回的是字符串长度。对于 capacity() 方法，返回的是 字符串 + 缓冲区 的大小。</li>
</ul>
<h1 id="12-4-StringBuilder类"><a href="#12-4-StringBuilder类" class="headerlink" title="12.4 StringBuilder类"></a>12.4 <code>StringBuilder</code>类</h1><blockquote>
<p>一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步（有线程安全问题）。该类被设计成 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先使用该类。因为在大多数实现中，它比起 StringBuffer 要快。<br>在 StringBuilder 是的主要操作是 append 和 insert 方法。可以重载这些方法，以接受任意类型的数据。</p>
</blockquote>
<ol>
<li><code>StringBuilder</code> 也继承了 <code>AbstractStringBuffer</code></li>
<li><code>StringBuilder</code> 也实现了 <code>Serialiazable</code>，可以串行化</li>
<li>仍然是在父类中有属性 <code>char[] value</code> ，而且不是 <code>final</code></li>
<li><code>StringBuilder</code> 也是一个 <code>final</code> 类，不能被继承</li>
<li><code>StringBuilder</code> 的方法，没有做互斥的处理（没有 <code>synchronize</code>），故而存在线程安全问题</li>
</ol>
<h2 id="12-4-1-String、StringBuffer、StringBuilder的对比"><a href="#12-4-1-String、StringBuffer、StringBuilder的对比" class="headerlink" title="12.4.1 String、StringBuffer、StringBuilder的对比"></a>12.4.1 <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>的对比</h2><ol>
<li><code>StringBuilder</code> 和 <code>StringBuffer</code> 类似，均代表可变字符序列，而且方法也一样</li>
<li><code>String</code>：不可变字符序列，效率低，但复用率高</li>
<li><code>StringBuffer</code>：可变字符序列，效率较高，线程安全</li>
<li><code>StringBuilder</code>：可变字符序列，效率最高，存在线程安全问题</li>
<li><code>String</code> 为何效率低：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;					<span class="comment">//创建了一个字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; <span class="number">100</span>; n++)&#123;		</span><br><span class="line">	str1 += <span class="string">&quot;bb&quot;</span>;					<span class="comment">//这里，原先的字符串被丢弃，创建新字符串</span></span><br><span class="line">&#125;									<span class="comment">//多次执行后，大量副本字符串留在内存中</span></span><br><span class="line">									<span class="comment">//导致效率降低，也会影响程序性能</span></span><br><span class="line"><span class="comment">//如上，对 String 大量修改的场合，不要使用 String</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="12-5-Math类"><a href="#12-5-Math类" class="headerlink" title="12.5 Math类"></a>12.5 <code>Math</code>类</h1><ul>
<li>Math.multiplyExact(int n1, int n2)：进行乘法运算，返回运算结果通常的乘法 n1 * n2 在结果大于那个数据类型存储上限时，可能返回错误的值。使用此方法，结果大于那个数据类型存储上限时，会抛出异常</li>
<li>Math.addExact(int n1, int n2)：加法</li>
<li>Math.subtractExact(int n1, int n2)：减法</li>
<li>Math.incrementExact(int n1)：自增</li>
<li>Math.decrementExact(int n1)：自减</li>
<li>Math.negateExact(int n1, int n2)：改变符号</li>
<li>Math.abs(n)：求绝对值，返回 |n1|</li>
<li>Math.pow(n, i)：求幂，返回 n3 ^ i</li>
<li>Math.ceil(n)：向上取整，返回 &gt;&#x3D; n3 的最小整数（转成double）</li>
<li>Math.floor(n)：向下取整，返回 &lt;&#x3D;n4 的最小整数（转成double）</li>
<li>Math.floorMod(int n1, int n2)：返回 n1 除以 n2 的余数n1 % n2 的场合，返回的可能是负数，而不是数学意义上的余数</li>
<li>Math.round(n)：四舍五入，相当于 Math.floor(n5 + 0.5)</li>
<li>Math.sqrt(n)：求开方。负数的场合，返回 NaN</li>
<li>Math.random()：返回一个 [0, 1) 区间的随机小数</li>
<li>Math.sin(n)：正弦函数</li>
<li>Math.cos(n)：余弦函数</li>
<li>Math.tan(n)、Math.atan(n)、Math.atan2(n)要注意，上述方法传入的参数是 弧度值。要得到一个角度的弧度值，应使用：Math.toRadians(n)</li>
<li>Math.exp(n)：e 的 n 次幂</li>
<li>Math.log10(n)：10 为底的对数</li>
<li>Math.log()：自然对数</li>
<li>Math.PI：圆周率的近似值</li>
<li>Math.E：e 的近似值</li>
</ul>
<h1 id="12-6-Arrays类"><a href="#12-6-Arrays类" class="headerlink" title="12.6 Arrays类"></a>12.6 <code>Arrays</code>类</h1><ul>
<li><p><code>Arrays.toString()</code>：返回数组的字符串形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">33</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Array.toString(nums);		<span class="comment">//此时，str = &quot;[0, 1, 33]&quot;</span></span><br><span class="line"><span class="comment">//特别的，输入为 null 时返回 “null”</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Arrays.sort(arr)</code>：排序</p>
</li>
</ul>
<p>因为数组是引用类型，使用 sort 排序后，会直接影响到实参。<br>默认（自然排序）从小到大排序。<br><code>Arrays.sort(arr, Comparator c)</code>：按照传入的比较器决定排序方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] nums;</span><br><span class="line">...</span><br><span class="line">Comparator&lt;Integer, Integer&gt; c = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer, Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n2 - n1;						<span class="comment">// 这个场合，变成从大到小排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(nums, c);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Arrays.binarySearch(array, num)</code>：通过二分搜索法查找。前提是必须先排序。</li>
</ul>
<p>找不到的场合，返回 - (low + 1)。即，其应该在的位置的负值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] nums2 = &#123;-<span class="number">10</span>, -<span class="number">5</span>, -<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(nums2, <span class="number">7</span>);	<span class="comment">// 此时 index = -7</span></span><br><span class="line">											<span class="comment">// 如果 7 存在，应该在第 7 个位置</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Arrays.copyOf(arr, n)</code>：从 <code>arr</code> 中，复制<code>n</code> 个元素（成为新的数组）。<code>n &gt; arr.length</code> 的场合，在多余的位置添加 <code>null</code>。<code>n &lt; 0</code> 的场合，抛出异常。该方法的底层使用的是 <code>System.arraycopy</code></li>
<li><code>Arrays.fill(arr, o)</code>：用 <code>o</code> 填充 <code>num</code> 的所有元素。</li>
<li><code>Arrays.equals(arr1, arr2)</code>：比较两个数组元素是否完全一致（<code>true/false</code>）</li>
<li><code>Arrays.asList(a, b, c, d)</code>：将输入数据转成一个 <code>List</code> 集合</li>
</ul>
<h1 id="12-7-System类"><a href="#12-7-System类" class="headerlink" title="12.7 System类"></a>12.7 <code>System</code>类</h1><ul>
<li><code>System.exit(0)</code>：退出当前程序。0 表示一个状态，正常状态是 0</li>
<li><code>System.arraycopy(arr, 0, newArr, 0 ,3)</code>：复制数组元素。上例是：<code>arr</code> 自下标 0 起开始，向 <code>newArr</code> 自下标 0 开始，依次拷贝 3 个值这个方法比较适合底层调用。我们一般使用 <code>Arrays.copyOf</code> 来做</li>
<li><code>System.currentTimeMillis</code>：返回当前时间距离 1970 - 1 - 1 的毫秒数</li>
<li><code>System.gc</code>：运行垃圾回收机制</li>
</ul>
<h1 id="12-8-BigInteger和BigDecimal类"><a href="#12-8-BigInteger和BigDecimal类" class="headerlink" title="12.8 BigInteger和BigDecimal类"></a>12.8 <code>BigInteger</code>和<code>BigDecimal</code>类</h1><blockquote>
<p><code>BigInteger</code>：适合保存更大的整数<br><code>BigDecimal</code>：适合保存精度更大的浮点数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用引号把大数变成字符串</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100000000000000000000000&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>构造方法：</strong></p>
<ul>
<li><code>new BigInteger(String intStr)</code>：通过一个字符串构建大数</li>
<li><code>BigInteger BigInteger.valueOf(1)</code>：通过静态方法，让整数类型转成大数</li>
</ul>
<p>另外，在对 <code>BigInteger</code> 和 <code>BigDecimal</code> 进行加减乘除的时候，需要使用对应方法<br>不能直接用 <code>+ - * /</code><br><strong>常用方法：</strong></p>
<ul>
<li><code>BigInteger add(BigInteger)</code>：加法运算。返回新的大数</li>
<li><code>BigInteger subtract(BigInteger)</code>：减法</li>
<li><code>BigInteger multiply(BigInteger)</code>：乘法</li>
<li><code>BigInteger divide(BigInteger)</code>：除法运算该方法可能抛出异常。因为可能产生是无限长度小数。解决方法（保留分子精度）：<code>bigDecimal.divide(bD3, BigDecimal.ROUND_CELLING)</code></li>
<li>一些常量：<code>BigInteger.ONE</code>、<code>BigInteger.ZERO</code>、<code>BigInteger.TEN</code> 分别是 1、0、10</li>
</ul>
<p>one 就是英文的 1，zero 就是英文的 0……这个大家都懂的吧？</p>
<h1 id="12-9-日期类"><a href="#12-9-日期类" class="headerlink" title="12.9 日期类"></a>12.9 日期类</h1><h2 id="12-9-1-第一代日期类"><a href="#12-9-1-第一代日期类" class="headerlink" title="12.9.1 第一代日期类"></a>12.9.1 第一代日期类</h2><blockquote>
<p>Date：精确到毫秒，代表特定瞬间。这里的是 java.util.Date<br>SimpleDateFormat：格式和解析日期的类</p>
</blockquote>
<ol>
<li><p><code>Date d1 = new Date();</code>：调用默认无参构造器，获取当前系统时间。默认输出日期格式是国外的格式，因此通常需要进行格式转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy.MM.dd HH.mm.ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateFormated</span> <span class="operator">=</span> sdf.(d1);							<span class="comment">//日期转成指定格式。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过指定毫秒数得到时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">10000000000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>把一个格式化的字符串转成对应的Date:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH点mm分 E&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">d3</span> <span class="operator">=</span> sdf2.parse(<span class="string">&quot;2021年12月22日 00点03分 星期三&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个场合，给定的字符串格式应和 <code>sdf2</code> 格式相同，否则会抛出异常</p>
</li>
</ol>
<h2 id="12-9-2-第二代日期类"><a href="#12-9-2-第二代日期类" class="headerlink" title="12.9.2 第二代日期类"></a>12.9.2 第二代日期类</h2><blockquote>
<p>Calendar：构造器是私有的，要通过 getInstance 方法获取实例</p>
</blockquote>
<ol>
<li><p>Calendar 是一个抽象类，其构造器私有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c1</span> <span class="operator">=</span> Calendar.genInstance();				<span class="comment">//获取实例的方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提供大量方法和字段提供给程序员使用Calendar 没有专门的格式化方法，需要程序员自己组合来显示</p>
<ul>
<li>c1.get(Calendar.YEAR)：获取年份数</li>
<li>c1.get(Calendar.MONTH)：获取月份数特别的，实际月份是 返回值 +1。因为 Calendar 的月份是从 0 开始编号的</li>
<li>c1.get(Calendar.DAY_OF_MONTH)：获取日数</li>
<li>c1.get(Calendar.HOUR)：获取小时数（12小时制）c1.get(Calendar.HOUR_OF_DATE)：获取小时数（24小时制）</li>
<li>c1.get(Calendar.MINUTE)：获取分钟数</li>
<li>c1.get(Calendar.SECOND)：获取秒数</li>
</ul>
</li>
</ol>
<h2 id="12-9-3-第三代日期类"><a href="#12-9-3-第三代日期类" class="headerlink" title="12.9.3 第三代日期类"></a>12.9.3 第三代日期类</h2><blockquote>
<p>JDK 1.0 加入的 Date 在 JDK 1.1 加入 Calendar 后已被弃用<br>然而，Calendar 也存在不足：</p>
<ol>
<li>可变性：像日期和实际这样的类应该是不可改变的</li>
<li>偏移性：年份都是从 1900 年开始，月份都是从 0 开始</li>
<li>格式化：只对 Date 有用，对 Calendar 没用</li>
<li>其他问题：如不能保证线程安全，不能处理闰秒（每隔 2 天多 1 秒）等</li>
</ol>
</blockquote>
<p>于是，在 JDK 8 加入了以下新日期类：</p>
<blockquote>
<ul>
<li>LocalDate：只包含 日期（年月日），可以获取 日期字段</li>
<li>LocalTime：只包含 时间（时分秒），可以获取 时间字段</li>
<li>LocalDateTime：包含 日期 + 时间，可以获取 日期 + 时间字段</li>
<li>DateTimeFormatter：格式化日期</li>
<li>Instant：时间戳</li>
</ul>
</blockquote>
<ol>
<li><p>使用 <code>now()</code> 方法返回当前时间的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();				<span class="comment">//获取当前时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取各字段方法：</p>
</li>
</ol>
<ul>
<li>ldt.getYear();：获取年份数</li>
<li>ldt.getMonth();：获取月份数（英文）ldt.getMonthValue();：获取月份数（数字）</li>
<li>ldt.getDayOfMonth();：获取日数</li>
<li>LocalDateTime ldt2 &#x3D; ldt.plusDays(100);：获取 ldt 时间 100 天后的时间实例</li>
<li>LocalDateTime ldt3 &#x3D; ldt.minusHours(100);：获取 ldt 时间 100 小时前的时间实例</li>
<li>…</li>
</ul>
<ol start="3">
<li><p>格式化日期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DateTimeFormatter</span>(<span class="string">&quot;yyyy.MM.dd HH.mm.ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> dtf.format(ldt);							<span class="comment">//获取格式化字符串</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Instant</code> 和 <code>Date</code> 类似</p>
<ul>
<li>获取当前时间戳：<code>Instant instant = Instant.now();</code></li>
<li>转换为 Date：<code>Date date = Date.form(instant);</code></li>
<li>由 Date 转换：<code>Instant instant = date.toInstant;</code></li>
</ul>
</li>
</ol>
<h1 id="12-10-泛型"><a href="#12-10-泛型" class="headerlink" title="12.10 泛型"></a>12.10 泛型</h1><blockquote>
<p>泛型（generic）：又称 参数化类型。是JDK 5 出现的新特性。解决数据类型的安全性问题。<br>在类声明或实例化时只要制定好需要的具体类型即可。</p>
</blockquote>
<p>举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties&lt;Person&gt; prop = <span class="keyword">new</span> <span class="title class_">Properties</span>&lt;Person&gt;();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上例表示存放到 prop 中的必须是 Person 类型。<br>如果编译器发现添加类型不符合要求，即报错。<br>遍历时，直接取出 Person 而非 Object</p>
</blockquote>
<ol>
<li>编译时，检查添加元素的类型。可以保证如果编译时没发出警告，运行就不会产生 ClassCastException 异常。提高了安全性，使代码更加简洁、健壮。</li>
<li>也减少了转换的次数，提高了效率。</li>
<li>泛型的作用是：可以在类声明是通过一个标识表示类中某个属性的类型，或某个方法返回值的类型，或参数类型。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">P</span>&lt;E&gt; &#123;</span><br><span class="line">	E e;				<span class="comment">//E 表示 e 的数据类型，在定义 P类 时指定。在编译期间即确认类型</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">P</span><span class="params">(E e)</span>&#123;		<span class="comment">//可作为参数类型</span></span><br><span class="line">		<span class="built_in">this</span>.e = e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> E <span class="title function_">doSth</span><span class="params">()</span>&#123;	<span class="comment">//可作为返回类型</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.e;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实例化时指定 E 的类型，编译时上例所有 E 会被编译器替换为那个指定类型<br><strong>使用方法：</strong></li>
</ol>
<ul>
<li><p><strong>声明泛型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceName</span>&lt;T&gt; &#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;A, B, C, D&gt; &#123;...&#125;</span><br><span class="line"><span class="comment">//上例 T、A、B、C、D 不是值，而是类型。可以用任意字母代替</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; iterator = vector.interator&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 类名后面指定类型参数的值</span></span><br></pre></td></tr></table></figure>
<p><strong>注意细节：</strong></p>
</li>
</ul>
<ol>
<li><p>泛型只能是引用类型</p>
</li>
<li><p>指定泛型具体类型后，可以传入该类型或其子类类型</p>
</li>
<li><p>在实际开发中往往简写泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>编译器会进行类型推断，右边 &lt; &gt; 内容可以省略</p>
</li>
<li><p>实例化不写泛型的场合，相当于默认泛型为 <code>Object</code></p>
</li>
</ol>
<p><strong>自定义泛型类 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>&lt;A, B...&gt; &#123;...&#125;				<span class="comment">//泛型标识符 可有多个，一般是单个大写字母表示</span></span><br></pre></td></tr></table></figure>
<p>这就是自定义泛型啊</p>
<ol>
<li><p>普通成员可以使用泛型（属性、方法）</p>
</li>
<li><p>泛型类的类型，是在创建对象时确定的。因此：静态方法中不能使用类的泛型；使用泛型的数组，也不能初始化。</p>
</li>
<li><p>创建对象时不指定的场合，默认 Object。建议还是写上 <Object>，大气，上档次</p>
</li>
<li><p>自定义泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Name</span>&lt;T, R...&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>泛型接口，其泛型在 继承接口 或 实现接口 时确定。<br><strong>自定义泛型方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;T, R...&gt; 返回类型 方法名(形参) &#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以定义在普通类中，也可以定义在泛型类中</p>
</li>
<li><p>当泛型方法被调用时，类型会确定</p>
</li>
<li><p>以下场合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class C&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cMethord</span><span class="params">(T t)</span>&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有 &lt; &gt;，不是泛型方法，而是使用了泛型的普通方法</p>
</li>
</ol>
<h4 id="泛型继承："><a href="#泛型继承：" class="headerlink" title="泛型继承："></a>泛型继承：</h4><ol>
<li>泛型不具有继承性</li>
<li><code>&lt;?&gt;</code>：支持任意泛型类型</li>
<li><code>&lt;? extends A&gt;</code>：支持 A 及 A的子类，规定了泛型的上限</li>
<li><code>&lt;? super B&gt;</code>：支持 B 及 B 的父类，规定了泛型的下限</li>
</ol>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>13. Java数据结构(集合)</title>
    <url>/2022/09/11/JavaSE/13.%20Java%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E9%9B%86%E5%90%88)/</url>
    <content><![CDATA[<blockquote>
<p>数据结构分为两种：线性结构、非线性结构</p>
</blockquote>
<p><strong>线性结构：</strong></p>
<ul>
<li>最常用的数据结构。数据元素间存在一对一线性关系。</li>
<li>线性结构有 2 种不同的存储结构：顺序储存结构，链式储存结构顺序存储结构中元素存储在连续的内存空间中。链式储存结构中元素储存在非连续的空间中，元素节点中存放数据元素及相邻元素的地址信息</li>
<li>常见的线性结构有：数组、队列、链表、栈等</li>
</ul>
<p><strong>非线性结构：</strong></p>
<ul>
<li>非线性结构包括：二维数组、多维数组、广义表、树结构、图结构</li>
</ul>
<h1 id="13-1-集合的框架体系"><a href="#13-1-集合的框架体系" class="headerlink" title="13.1 集合的框架体系"></a>13.1 集合的框架体系</h1><blockquote>
<p>Java 提供了一系列集合容器，以方便程序员动态保存元素。并提供了一系列方便的操作对象的方法。<br>Java 集合主要分为两组：单列集合（Collection）、双列集合（Map）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/28255706/1660366812532-db8915d2-eda5-462b-a8dd-46baa909c19d.png#clientId=u900872a1-d44d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=uc0f92870&margin=%5Bobject%20Object%5D&name=%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE_13.1.png&originHeight=641&originWidth=950&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41859&status=done&style=none&taskId=u3c1c40fc-0853-446d-b334-d8c7813b1af&title=" alt="集合体系图_13.1.png"></p>
<ul>
<li><strong>Collection 接口（单列集合）</strong>：可以存放多个元素。每个元素可以是 ObjectCollection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）</li>
<li><strong>Map 接口（双列集合）</strong>：用于保存具有映射关系的数据：key - value（双列元素）key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value</li>
</ul>
<h1 id="13-2-单列集合接口-Collection"><a href="#13-2-单列集合接口-Collection" class="headerlink" title="13.2 单列集合接口 Collection"></a>13.2 单列集合接口 Collection</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Lterable</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Collection 实现子类可以存放多个元素。每个元素可以是 Object<br>有些 Collection 实现子类能存放重复的元素，有些不能<br>有些 Collection 实现子类是有序的（List） ，有些不是（Set）<br>Collection 接口没有直接的实现子类，都是通过其子接口实现的</p>
</blockquote>
<p><strong>常用方法：</strong></p>
<ul>
<li><p><code>add</code>:添加单个元素**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;哈哈啊&quot;</span>);</span><br><span class="line">list.add(<span class="number">10</span>);				<span class="comment">// 相当于List.add(new Integer(10));</span></span><br><span class="line">list.add(<span class="literal">true</span>);				<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>remove</code>: 删除单个元素**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.remove(<span class="number">0</span>)				<span class="comment">// 删除编号 0 的元素。上例中会删除 &quot;哈哈啊&quot;</span></span><br><span class="line">list.remove((Integer)<span class="number">10</span>);	<span class="comment">// 删除上例的 10 要这样写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>contains</code>：检查元素是否存在</p>
</li>
<li><p><code>size</code>：获取元素个数</p>
</li>
<li><p><code>isEmpty</code>：判断是否为空</p>
</li>
<li><p><code>clear</code>：清空</p>
</li>
<li><p><code>addAll</code>：添加多个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list2.add(<span class="number">111</span>);</span><br><span class="line">list2.add(<span class="string">&quot;idea&quot;</span>);</span><br><span class="line">list.addAll(list2);			<span class="comment">// 这里可以输入所有实现了 Collection 接口的集合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>containsAll</code>: 检查多个元素是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.contaionsAll(list2);	<span class="comment">// 同上，放一个实现了 Collection 接口的集合</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>removeAll</code>: 删除多个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.removeAll(list2);		<span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Iterator iterator()</code>：返回指向集合开始位置的迭代器</p>
</li>
</ul>
<h2 id="13-2-1-迭代器-Iterator"><a href="#13-2-1-迭代器-Iterator" class="headerlink" title="13.2.1 迭代器 Iterator"></a>13.2.1 迭代器 Iterator</h2><blockquote>
<p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。<br>Collection 继承的 Iterable 接口中，提供了 iterator() 方法，会返回一个新的迭代器。<br>Iterator 对象仅用于遍历集合，本身不存放元素<br>IDEA 中，迭代器 while 循环的模板快捷键：itit</p>
</blockquote>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>boolean hasNext()</code>：该方法判断是否有下一个元素。</li>
<li><code>T next()</code>：该方法会将指针下移，然后返回下移后的位置上的元素</li>
</ul>
<p><strong>用迭代器遍历元素：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Object&gt; c = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;Object&gt; iterator = c.iterator();		<span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;						<span class="comment">// [2]</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();				<span class="comment">// [3]</span></span><br><span class="line">	System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>获取迭代器</li>
<li>判断有无下一元素</li>
<li>将迭代器后移，并返回那个后移位置上的元素while 循环结束后，指针指向最后元素的位置。再次 next() 会报错。如果需要再使用，需要重置迭代器。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iterator = list.iterator();				<span class="comment">// 重置了迭代器</span></span><br></pre></td></tr></table></figure>
<strong>for each（增强 for 循环）：</strong><br>for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组 中的元素<br>IDEA 中，增强 for 循环的模板快捷键：I<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object o : list)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>for each 可在 Collection 集合中使用。</li>
<li>for each 的底层在本质上也是 Iterator。可以理解为简化版本的迭代器遍历。</li>
</ul>
<h1 id="13-3-有序集合接口-List"><a href="#13-3-有序集合接口-List" class="headerlink" title="13.3 有序集合接口 List"></a>13.3 有序集合接口 List</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<p>List 是 Collection 接口的子类接口<br>List 是有序（添加顺序和取出顺序一致）的，可重复的<br>List 中的每个元素都有其对应的顺序索引（从 0 开始编号）<br><strong>常用方法：</strong></p>
<ul>
<li><p>add(int, obj)：在 int 位置插入 obj 元素。返回 true</p>
</li>
<li><p>add(obj)：在末尾插入 obj。返回 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="number">111</span>);</span><br><span class="line">list.add(<span class="number">0</span>, <span class="number">110</span>);						<span class="comment">// 在第 1 个位置插入数字 110</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>addElement(obj)：在末尾插入 obj。无返回值。你说要这方法有啥用？名字还长一截</p>
</li>
<li><p>addAll(int, collection)：在 int 位置插入 collection 中的所有元素</p>
</li>
<li><p>get(int)：返回 int 位置的元素</p>
</li>
<li><p>indexOf(obj)：返回 obj 首次出现时的位置</p>
</li>
<li><p>lastIndexOf(obj)：返回 obj 最后一次出现时的位置</p>
</li>
<li><p>remove(int)：移除 int 位置的元素，并返回那个被移除的元素</p>
</li>
<li><p>set(int, obj)：设置 int 位置的元素为 obj。相当于替换。返回那个被替换元素的下标setElement(obj, int)：设置 int 位置的元素为 obj。无返回值</p>
</li>
<li><p>subList(int1, int2)：返回 [int1, int2) 范围的元素构成的子集合</p>
</li>
</ul>
<h2 id="13-3-1-可变数组-ArrayList"><a href="#13-3-1-可变数组-ArrayList" class="headerlink" title="13.3.1 可变数组 ArrayList"></a>13.3.1 可变数组 ArrayList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">     <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p>ArrayList 是 List 的实现子类。其底层由数组来实现存储。<br>ArrayList 可以存放 null<br><strong>ArrayList 的源码：</strong></p>
<ol>
<li><p>ArrayList 中维护了一个 Object 类型的数组 elementData。该数组就是用来存放元素的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 ArrayList 对象时，如果使用无参构造器，则 elementData[] 初始容量为 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用指定大小构造器，则初始容量为指定大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">/* 这个场合，与默认构造器的不同之处在于</span></span><br><span class="line"><span class="comment">		扩容时，该 0 容量变为 1，而默认构造器会变为 10 */</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容的场合：</p>
</li>
</ol>
<p>如果是** 无参构造器生成的初始 0 长度的 elementData**，则将其容量置为 10。<br>否则容量扩容为 1.5 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 扩容方法，传入的参数 minCapacity 是容器现有元素数量 + 1 的值</span></span><br><span class="line"><span class="comment">	如果是无参构造器生成的默认数组，此时传入固定值 10 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">/* 计算新的容量（旧容量的 1.5 倍）</span></span><br><span class="line"><span class="comment">    	此处 &gt;&gt; 为位运算符，等同于 newC = oldC + oldC / 2; */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 这里如果原容量是特殊值（1 或 0），容量会变为那个 minCapacity 的值 */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-3-2-可变数组-Vector"><a href="#13-3-2-可变数组-Vector" class="headerlink" title="13.3.2 可变数组 Vector"></a>13.3.2 可变数组 Vector</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Vector</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Vector 是 List 的实现子类。其底层由数组来实现存储<br>Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector 线程安全。<br>在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList。</p>
</blockquote>
<p><strong>Vector 的底层源码：</strong></p>
<ol>
<li><p>底层维护了一个 Object 类型的数组 elementData。用以存放元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用无参构造器创建对象时，默认大小是 10</p>
</li>
</ol>
<p>使用有参构造器的场合，默认是那个指定大小（initialCapaticy）<br>也能在构造器中指定那个扩容的增长速度（capacityIncrement）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Vector</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">int</span> capacityIncrement)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(...);</span><br><span class="line">    <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    <span class="built_in">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>扩容的场合，容量变成 2 倍</li>
</ol>
<p>使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">/* 计算新的容量（按照指定的增速扩容）</span></span><br><span class="line"><span class="comment">    	那个指定无效或未指定时，容量变为 2 倍 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                     capacityIncrement : oldCapacity);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-3-3-链表-LinkedList"><a href="#13-3-3-链表-LinkedList" class="headerlink" title="13.3.3 链表 LinkedList"></a>13.3.3 链表 LinkedList</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>LinkedList 是 List 的实现子类，底层以链表形式存储元素。<br>链表是一种非线性结构：其以节点方式存储，节点间在内存上的位置不连续。<br>链表是有序的列表。单向链表每个节点包含 data 域和 next 域。那些 next 域指向下一节点的位置。<br>双向链表在单向链表的基础上，每个节点加入 prev 区域以指示其前方节点。这样，就能实现双向查找。双向链表可以不依靠辅助节点而实现自我删除。<br>LinkedList 底层实现了 双向链表 和 双端队列 特点。<br>LinkedList 可以添加 null，可添加重复元素。但没有实现同步，因此线程不安全。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/28255706/1660375592427-e6ff720f-b420-4f62-850f-83615e33048f.png#clientId=u900872a1-d44d-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=ub042fae1&margin=%5Bobject%20Object%5D&name=%E9%93%BE%E8%A1%A8%E5%9B%BE_13.3.3.png&originHeight=421&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=170756&status=done&style=none&taskId=u64a6d58a-e275-40ba-a8b9-d411766f0d0&title=" alt="链表图_13.3.3.png"><br><strong>常用方法：</strong></p>
<ul>
<li>void addLast(E e)：尾插一个新的元素LinkedList 的 add 方法即调用该方法</li>
<li>void addFirst(E e)：头插一个新的元素</li>
<li>E removeLast()：移除并返回尾部元素。为空时报错</li>
<li>E poll()：移除并返回尾部元素。为空时返回 null</li>
<li>E removeFirst()：移除并返回头部元素。为空时报错</li>
<li>E getLast()：仅返回尾部元素。为空时报错</li>
<li>E peek()：返回尾部元素。为空时返回 null</li>
<li>E element()：返回头部元素。为空时返回 null</li>
<li>E getFirst()</li>
</ul>
<p><strong>LinkedList 的源码：</strong></p>
<ol>
<li><p>LinkedList 只有默认构造器和一个拷贝构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>LinkedList 底层维护了一个 双向链表</p>
</li>
</ol>
<p>两个属性 first、last 分别指向 首节点 和 尾节点<br>每个节点（Node 对象），里面又维护了 prev、next、item 属性。<br>其中通过 prev 指向前一个节点，通过 next 指向后一个节点。最终实现双向链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>LinkedList 不需要扩容。其增删元素时只要改变节点的指向即可。也因此，其添加、删除元素效率比数组更高</li>
</ol>
<p><strong>ArrayList 和 LinkedList 的比较：</strong></p>
<p>| **</p>
<p> | <strong>底层结构</strong> | <strong>增删效率</strong> | <strong>改查效率</strong> |<br>| — | — | — | — |<br>| ArrayList | 可变数组 | 低（数组扩容） | 高 |<br>| LinkedList | 双向链表 | 高（链表追加） | 低 |</p>
<p>应该根据实际情况来选择使用的集合：</p>
<ul>
<li>如果改查操作多，选择 ArrayList。一般来说，在程序中，80% - 90% 都是查询。大部分情况下，选择 ArrayList。</li>
<li>如果增删操作多，选择 LinkedList</li>
</ul>
<h1 id="13-4-双列集合接口-Map"><a href="#13-4-双列集合接口-Map" class="headerlink" title="13.4 双列集合接口 Map"></a>13.4 双列集合接口 Map</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure>
<p><strong>以下关于 Map 接口的描述，适用于 JDK 8 的环境</strong></p>
<blockquote>
<p>Map 与 Collection 并列存在，用于保存具有映射关系的数据：key - value（双列元素）<br>Map 的 key 和 value 可以是任何类型的引用数据类型，也能存入 null。<br>Map 的 key 不允许重复，value 可以重复。key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value。<br>一组 k - v 会被封装到一个 Entry 对象中。Entry 是一个内部接口。Map 的实现子类中都包含一个实现这个接口的内部类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K,V&gt; &#123;</span><br><span class="line">	K <span class="title function_">getKey</span><span class="params">()</span>;</span><br><span class="line">	V <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加相同的 key，会覆盖原先的 key -value。等同于修改（key 不会替换，value 会被替换）<br><strong>常用方法：</strong></p>
<ul>
<li>put()：添加。已存在的场合，实行替换。（key 不替换，value 替换）</li>
<li>remove()：根据键删除映射关系</li>
<li>get()：根据键获取值</li>
<li>size()：元素个数</li>
<li>isEmpty()：判断个数是否为 0</li>
<li>clear()：清空</li>
<li>containsKey()：查找键是否存在</li>
<li>Set<K> keySet()：获取所有 键 构成的集合Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有 Entry 构成的集合Collection<V> values()：获取所有 值 构成的集合</li>
</ul>
<p><strong>Map接口遍历元素：</strong></p>
<ul>
<li><strong>方法一： 利用<code>Set&lt;K&gt; keySet()</code> 方法</strong></li>
</ul>
<p>先得到所有 keys，再遍历 keys，根据每个 key 获得 value：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Object o : keyset) &#123;</span><br><span class="line">	System.out.println(o + <span class="string">&quot; = &quot;</span> + map.get(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法二：利用 Set<V> values() 方法</strong></li>
</ul>
<p>直接把所有 values 取出，之后遍历 values</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法三：利用 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 方法</strong></li>
</ul>
<p>通过获取 entrySet 来获取 k - v</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : entrySet) &#123;</span><br><span class="line">	System.out.println(e.getKey() + <span class="string">&quot; - &quot;</span> + e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-4-1-散列表-HashMap"><a href="#13-4-1-散列表-HashMap" class="headerlink" title="13.4.1 散列表 HashMap"></a>13.4.1 散列表 HashMap</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HashMap 是 Map 接口使用频率最高的实现类。是根据关键码值（key value）而进行直接访问的数据结构。通过将关键码值映射到表中一个位置来访问记录，以加快查找速度。<br>那个映射函数叫做散列函数，存放记录的数组叫做散列表（哈希表）<br>HashMap 是以 k - v 对得到方式来存储数据。一组数据会被封装到一个 Node 对象中。HashMap 是 Map 接口使用频率最高的实现类。是根据关键码值（key value）而进行直接访问的数据结构。通过将关键码值映射到表中一个位置来访问记录，以加快查找速度。<br>那个映射函数叫做散列函数，存放记录的数组叫做散列表（哈希表）<br>HashMap 是以 k - v 对得到方式来存储数据。一组数据会被封装到一个 Node 对象中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line"> <span class="keyword">final</span> K key;</span><br><span class="line"> V value;</span><br><span class="line"> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JDK 7 前，HashMap 底层是 数组 + 链表。JDK 8 后，底层是 数组 + 链表 + 红黑树。HashMap 不保证映射的顺序。<br>HashMap 没有实现同步（没有 synchronized），是线程不安全的</p>
</blockquote>
<p><strong>HashMap 的源码：</strong></p>
<ol>
<li><p>HashMap 底层维护了 Node 类型的数组 table。默认为 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p>另外，还有集合 values、keySet、enrtySet。这些集合能帮助程序员进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;				keySet;</span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt;			values;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt;	entrySet;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象时，默认构造器将加载因子（loadfactor）初始化为 0.75。</p>
</li>
</ol>
<p>也能指定那些初始容量和加载因子。<br>默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 &#x3D; 12。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;					<span class="comment">// 这个默认构造的场合，其他参数都是默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(...);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(...);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加时容量不够的场合，需要扩容。</li>
</ol>
<p>默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 &#x3D; 12。<br>扩容的场合，容量变为 2 倍。临界值相应变化。<br>临界值不会超过那个指定的 MAXIMUM_CAPACITY（1 &lt;&lt; 30），否则变成 Integer.MAX_VALUE。<br>JDK 8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD（默认是 8），并且 table 的大小 &gt;&#x3D; MIN_TREEIFY_CAPACITY（默认 64），会进行树化。<br>剪枝：红黑树的元素减少到一定程度，会被重新转化为 链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;								<span class="comment">// &lt;- 旧的数据数组 table</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;		<span class="comment">// &lt;- 旧的 table 的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;									<span class="comment">// &lt;- 旧的临界值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;									<span class="comment">// &lt;- 新的容量、临界值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 旧的数组不为空时，</span></span><br><span class="line"><span class="comment">    	如果容量已达指定的 MAXIMUM_CAPACITY，则不扩容</span></span><br><span class="line"><span class="comment">    	否则扩容为 2 倍容量，临界值也变为 2 倍 */</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCap = oldCap &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 旧的数组为空，但临界值已被指定（原因是：指定构造器传入初始容量为 0） */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">/* 旧的数组为空，临界值为 0（原因是：使用默认构造器）</span></span><br><span class="line"><span class="comment">    	默认构造器初始化容量为 16，默认临界因子为 0.75f */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 到这里，newThr（新临界值）为 0 的原因可能是：</span></span><br><span class="line"><span class="comment">    	1. 旧容量小于那个最小容量（16）</span></span><br><span class="line"><span class="comment">    	2. 扩容后容量大于那个最大容量</span></span><br><span class="line"><span class="comment">    	3. 旧的临界值为 0 或 Integer.MIN_VALUE</span></span><br><span class="line"><span class="comment">    	4. 构造器传入初始容量为 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 按照 新容量 * 临界因子 的方法计算临界值。临界值不会超过一个指定的最大值 */</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 确定了容量和临界值，下面把旧数组元素移至新数组。</span></span><br><span class="line"><span class="comment">    	那个移动的场合，会以新容量重新计算所有元素的下标位置 */</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>添加 k - v 时，通过 key 的哈希值得到其在 table 的索引，判断索引位置是否被占用。</li>
</ol>
<p>未占用的场合，直接添加。<br>占用的场合，判断其 key 是否相等。相等的场合，替换 value。否则，按照 树 或 链表 的方式处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 会先对放入元素的哈希值进行一次计算，得到一个数字：hash */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h ^ (h &gt;&gt;&gt; <span class="number">16</span>));	<span class="comment">// 位运算符：&gt;&gt;&gt; 无符号右移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* put 方法会调用该 putVal 方法。</span></span><br><span class="line"><span class="comment">	那些传入值是：	hash、	key、	value、			false、				true */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab = table; 		<span class="comment">// &lt;- 是那个存放数据的 table 数组</span></span><br><span class="line">    <span class="type">int</span> n;							<span class="comment">// &lt;- 是 table.length</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果原先的 table 为空，则对其重新分配空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        tab = resize();</span><br><span class="line">        n = tab.length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 用方才计算的 hash 数，得到要放入元素的下标值 i</span></span><br><span class="line"><span class="comment">    	n - 1 是数据数组的最大下标，(n - 1) &amp; hash 必定不大于 n - 1 */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;			<span class="comment">// 位运算符：&amp; 按位与</span></span><br><span class="line">    Node&lt;K,V&gt; p = tab[i];			<span class="comment">// 得到 table 中，位于那个插入位置的元素</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 倘若该位置为空，则直接放入 */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 该位置不为空，意味着可能添加了重复元素 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; 			<span class="comment">// &lt;- 被发现重复的那个 Node。无重复时结果为 null。这个 Node 的 value 会被替换。</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> p.key;			<span class="comment">// &lt;- 当前取出进行比较的 key 值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 为了验证其是否重复，这里要进行如下比较：</span></span><br><span class="line"><span class="comment">        	1. 比较两者的 hash 数。不同的场合是不同元素</span></span><br><span class="line"><span class="comment">        	2. 使用 == 和 equals 两种方法比较 key。不同的场合是不同元素 </span></span><br><span class="line"><span class="comment">        	如果是相同元素，则该节点的值会被替换 */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; (k  == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            e = p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 此处节点结构是 树 的场合，还需遍历比较树的每个节点 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 此处节点结构是 链表 的场合，还需遍历比较每个链表节点 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                e = p.next;</span><br><span class="line">                <span class="comment">/* e == null 意味着遍历结束，全部不同。这样，在此处添加那个新的 Node */</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* 故技重施，如果发现相同，则替换那个新元素 */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 经历上述比较后，e != null 意味着有元素要被替换了 */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">/* 传入的参数 onluIfAbsent == false，所以此处一定是 true */</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);		<span class="comment">// &lt;- HashMap 中，该方法为空实现。</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果到达这里，说明添加了元素（而非替换），要查看大小是否超过临界值 */</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);		<span class="comment">// &lt;- HashMap 中，该方法为空实现。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 上面提到的一些空实现的方法 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-4-2-散列表-HashTable"><a href="#13-4-2-散列表-HashTable" class="headerlink" title="13.4.2 散列表 HashTable"></a>13.4.2 散列表 HashTable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Hashtable 和 HashMap 基本一致，但Hashtable 是线程安全的 。但也因为如此，Hashtable 的效率低下。</p>
</blockquote>
<p><strong>Hashtable 与 HashMap 的比较：</strong></p>
<p>| **</p>
<p> | <strong>版本</strong> | <strong>线程安全（同步）</strong> | <strong>效率</strong> | <strong>是否允许 null值</strong> |<br>| — | — | — | — | — |<br>| Hashtable | 1.0 | 安全 | 较低 | 不允许 |<br>| HashMap | 1.2 | 不安全 | 高 | 允许 |</p>
<ul>
<li><p>Hashtable 底层也是有数组，默认构造器的初始容量为 11。临界值是 11 * 0.75 &#x3D; 8。</p>
</li>
<li><p>扩容大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;			<span class="comment">//即，原容量 * 2 + 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Hashtable 不会树化</p>
</li>
</ul>
<h3 id="13-5-3-红黑树-TreeMap"><a href="#13-5-3-红黑树-TreeMap" class="headerlink" title="13.5.3 红黑树 TreeMap"></a>13.5.3 红黑树 TreeMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableMap</span>&lt;K,V&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TreeMap 实现了 Map 接口。底层使用 红黑树 存储数据。<br>相较数组（访问快，检索、插入慢）和链表（插入快，检索、访问慢），树形数据结构（如二叉排序树）在保证数据检索速度的同时，也能保证数据插入、删除、修改的速度</p>
</blockquote>
<p><strong>TreeMap的源码：</strong></p>
<ol>
<li><p>TreeMap 底层维护了一个二叉树，以及一个比较器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象时，能采用无参构造，也能指定比较器完成构造，那个无参构造的场合，比较器为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">    comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较器如果为空，则要求传入的 key 必须是 Comparable 接口的实现子类，否则无法进行比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object k1, Object k2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="literal">null</span> ? ((Comparable&lt;? <span class="built_in">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加时，通过比较器确定那个添加位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;	<span class="comment">// &lt;- 树的根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 二叉树为空的场合，创建根节点，将数据放入 */</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        compare(key, key);</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cmp;				<span class="comment">// &lt;- 临时值，存放比较结果</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;		<span class="comment">// &lt;- 临时值，存放父节点</span></span><br><span class="line">    Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;		<span class="comment">// &lt;- 比较器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 有比较器的场合，按照这个方法进行比较 */</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 比较器为空的场合，按照这个方法进行比较 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将数据节点放到正确的路径下 */</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 此处会试着将该树转换成完全二叉树 */</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加的最后，会试着将该树转换成完全二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="13-4-4-Properties"><a href="#13-4-4-Properties" class="headerlink" title="13.4.4 Properties"></a>13.4.4 Properties</h2><blockquote>
<p>Properties 继承自 Hashtable 并实现了 Map 接口。也使用键值对的方式保存数据<br>Properties 使用特点与 Hashtable 相似<br>Properties 还可以用于 xxx.properties 文件中，加载数据到 Properties 对象，进行读取和修改<br>xxx.properties 文件常作为配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>String getProperty(String key)</code>：输入一个 String 类型的 key，返回一个 String 的 value<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">oval</span> <span class="operator">=</span> <span class="built_in">super</span>.get(key);</span><br><span class="line"><span class="type">String</span> <span class="variable">sval</span> <span class="operator">=</span> (oval <span class="keyword">instanceof</span> String) ? (String)oval : <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> ((sval == <span class="literal">null</span>) &amp;&amp; (defaults != <span class="literal">null</span>)) ? defaults.getProperty(key) : sval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="13-5-无序集合接口Set"><a href="#13-5-无序集合接口Set" class="headerlink" title="13.5 无序集合接口Set"></a>13.5 无序集合接口Set</h1><blockquote>
<p>Set 是 Collection 接口的子类接口。<br>Set 接口的特点是无序（添加和取出顺序不一致，其取出顺序由某个算法决定），没有索引<br>不允许重复元素。故而，最多包含一个 null</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt;</span><br></pre></td></tr></table></figure>
<h2 id="13-5-1-HashSet"><a href="#13-5-1-HashSet" class="headerlink" title="13.5.1 HashSet"></a>13.5.1 HashSet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>HashSet 实现了 Set 接口。底层实际上使用 HashMap 来存储数据。身在 Collection 心在 Map<br>HashSet 是无序的。其实际顺序取决于计算得到的 hash 值</p>
</blockquote>
<p><strong>HashSet的源码：</strong></p>
<ol>
<li><p>HashSet 底层是 HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例化也和 HashMap 相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加一个元素时调用 HashMap 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="13-5-2-LinkedHashSet"><a href="#13-5-2-LinkedHashSet" class="headerlink" title="13.5.2 LinkedHashSet"></a>13.5.2 LinkedHashSet</h2><blockquote>
<p>LinkedHashSet 是 HashSet 的子类<br>LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 + 双向链表。有其父必有其子<br>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedHashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<p><strong>LinkedHashSet的源码：</strong></p>
<ol>
<li>在类 HashSet 中，存在一个默认访问范围的构造器。该构造器不同于其他构造器，会让实例维护一个 LinkedHashMap<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
LinkedHashSet 的构造器即调用了该父类构造器<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="13-5-3-TreeSet"><a href="#13-5-3-TreeSet" class="headerlink" title="13.5.3 TreeSet"></a>13.5.3 TreeSet</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TreeSet 实现了 Set 接口，其底层是一个 TreeMap。好家伙，原来 Set 全家都是卧底<br>调用无参构造器创建 TreeSet 时，默认是无序排列。也能在构造时传入一个比较器。有比较器的场合，比较器返回 0 时，不发生替换<br>不传入比较器的场合，使用的是传入对象自带的比较器。所以，这个场合，传入的 key 对象必须是 Comparable 接口的实现子类</p>
</blockquote>
<h1 id="13-6-集合的选择"><a href="#13-6-集合的选择" class="headerlink" title="13.6 集合的选择"></a>13.6 集合的选择</h1><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行分析选择。<br>判断存储的类型（一组对象 [单列]，或一组键值对 [双列]）</p>
<ul>
<li>一组对象：Collection 接口<ul>
<li>允许重复：List<ul>
<li>增删多：LinkedList （双向链表）</li>
<li>改查多：ArrayList （Object[] 数组）</li>
</ul>
</li>
<li>不允许重复：Set<ul>
<li>无序：HashSet （数组 + 链表 + 红黑树，底层是 HashMap）</li>
<li>排序：TreeSet</li>
<li>顺序一致：LinkedHashSet （数组 + 双向链表，底层是 LinkedHashMap）</li>
</ul>
</li>
</ul>
</li>
<li>一组键值对：Map<ul>
<li>键无序：HashMap （数组 + 链表 + 红黑树 [ JDK 8 以后 ] ）</li>
<li>键排序：TreeMap</li>
<li>键顺序一致：LinkedHashMap （底层是 HashMap）</li>
<li>读取文件：Properties</li>
</ul>
</li>
</ul>
<h1 id="13-7-工具类-Collections"><a href="#13-7-工具类-Collections" class="headerlink" title="13.7 工具类 Collections"></a>13.7 工具类 Collections</h1><blockquote>
<p>Collections 工具类是一个操作 Set、List、Map 等集合的工具类<br>其中提供了一系列静态方法，对集合元素进行 排序、查询和修改等操作</p>
</blockquote>
<p><strong>常用方法：</strong><br>排序：</p>
<ul>
<li>reverse(List)：反转 List 中元素的排序</li>
<li>shuffle(List)：对 List 中元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素升序排列</li>
<li>reverse(List, Comparator)：根据指定 Comparator 对 List 排序</li>
<li>swap(List, int, int)：将两处元素位置互换</li>
</ul>
<p>查找、替换：</p>
<ul>
<li>Object max(Collection)：根据元素的自然排序，返回集合中最大的元素</li>
<li>Object max(Collection, Comparator)：根据比较器，返回最大元素</li>
<li>Object min(Collection)：根据元素的自然排序，返回最小元素</li>
<li>Object min(Collection, Comparator)：根据比较器，返回最小元素</li>
<li>int frequency(Collection, Object)：返回集合中指定元素的出现次数</li>
<li>void copy(List dest, List src)：将 src 的内容复制到 dest 中这个场合，要保证 dest 的大小不小于 src。所以，可能需要先给 dest 赋值</li>
<li>boolean replaceAll(List list, Object oldVal, Object newVal)：用 newVal 替换所有 oldVal 值</li>
</ul>
<p><strong>常用方法：</strong><br>排序：</p>
<ul>
<li>reverse(List)：反转 List 中元素的排序</li>
<li>shuffle(List)：对 List 中元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素升序排列</li>
<li>reverse(List, Comparator)：根据指定 Comparator 对 List 排序</li>
<li>swap(List, int, int)：将两处元素位置互换</li>
</ul>
<p>查找、替换：</p>
<ul>
<li>Object max(Collection)：根据元素的自然排序，返回集合中最大的元素</li>
<li>Object max(Collection, Comparator)：根据比较器，返回最大元素</li>
<li>Object min(Collection)：根据元素的自然排序，返回最小元素</li>
<li>Object min(Collection, Comparator)：根据比较器，返回最小元素</li>
<li>int frequency(Collection, Object)：返回集合中指定元素的出现次数</li>
<li>void copy(List dest, List src)：将 src 的内容复制到 dest 中这个场合，要保证 dest 的大小不小于 src。所以，可能需要先给 dest 赋值</li>
<li>boolean replaceAll(List list, Object oldVal, Object newVal)：用 newVal 替换所有 oldVal 值</li>
</ul>
<h1 id="13-8-JUnit"><a href="#13-8-JUnit" class="headerlink" title="13.8 JUnit"></a>13.8 JUnit</h1><blockquote>
<p>一个类有多个功能代码需要测试，为了测试，就要写入 main 方法中<br>如果有多个功能代码测试，需要反复撤销，过程繁琐<br>JUnit 是一个 Java 语言单元测试框架<br>多数 Java 开发环境都已集成了 JUnit 作为单元测试工具<br><a href="https://www.bilibili.com/video/BV1fh411y7R8?p=566&t=259.3">使用方法</a><br>……总的来讲，方法就是加入 @Test，然后 alt + enter 引入 JUnit 5，最后运行</p>
</blockquote>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 多线程(基础)</title>
    <url>/2022/09/11/JavaSE/14.%20%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="14-1-线程的概念"><a href="#14-1-线程的概念" class="headerlink" title="14.1 线程的概念"></a>14.1 线程的概念</h1><blockquote>
<p>对于一般程序而言，其结构大都可以分为一个入口、一个出口、一个顺次执行的语句序列。这样的语句结构称为进程，它是程序的一次动态执行，对应了代码加载、执行至完毕的全过程。<br>进程即是程序在处理机中的一次运行。在这样一个结构中不仅包含程序代码，也包括了系统资源的概念。<br>在单 CPU 计算机内部，微观上讲，同一时间只能有一个线程运行。实现多线程即从宏观上使多个作业同时执行。</p>
</blockquote>
<p>程序：为完成特定任务，用某种语言编写的一组指令的集合。<br>进程：运行中的程序。当你运行一个程序，系统就会为该进程分配空间。进程是程序的一次执行过程。是一个动态过程：有其自身产生、存在、消亡的过程。<br>线程：由进程创建的，进程的一个实体。一个进程可以有多个线程。<br>单线程：同一时刻，只允许执行一个线程。<br>多线程：同一时刻，可以执行多个线程。<br>并发：同一时刻，多个任务交替执行，造成一种貌似并行的状态。单核 CPU 实现的多任务就是并发。<br>并行：同一时刻，多个任务同时进行。多核 CPU 可以实现并行。</p>
<h2 id="14-1-1-线程的结构"><a href="#14-1-1-线程的结构" class="headerlink" title="14.1.1 线程的结构"></a>14.1.1 线程的结构</h2><p>在 Java 中，线程由以下 3 部分组成：</p>
<ul>
<li>虚拟 CPU：封装在 java.lang.Thread 类中，控制着整个线程的运行</li>
<li>执行的代码：传递给 Thread 类，由其控制按序执行</li>
<li>处理的数据：传递给 Thread 类，是在代码执行过程中需要处理的数据</li>
</ul>
<h2 id="14-1-2-线程的状态"><a href="#14-1-2-线程的状态" class="headerlink" title="14.1.2 线程的状态"></a>14.1.2 线程的状态</h2><blockquote>
<p>Java 的线程是通过包 java.lang 中定义的类 Thread 来实现的。当生成了一个 Thread 类后就产生了一个线程。通过该对象实例，可以启动线程、终止线程，或暂时挂起线程</p>
</blockquote>
<p>线程共有 4 种状态：新建（New）、可运行（Runnable）、死亡（Dead）、阻塞（Blocked）</p>
<ul>
<li><strong>新建（New）</strong>：线程对象刚刚创建，还未启动（New）。此时还处于不可运行状态，但已有了相应内存空间及其他资源</li>
<li><strong>可运行（Runnable）</strong>：此时线程已经启动，处于线程的 run() 方法中。这种情况下线程可能正在运行；也可能没有运行，但只要 CPU 空闲就会立刻运行。可以运行但没在运行的线程都排在一个队列中，这个队列称为就绪队列。可运行状态下，运行中的线程处于运行状态（Running），未运行线程处于就绪状态（Ready）。调用 start() 方法可以让线程进入可运行状态。</li>
<li><strong>死亡（Dead）</strong>：线程死亡（Terminated）的原因有两个：一是 run() 方法最后一个语句执行完毕，二是线程遇到异常退出</li>
<li><strong>阻塞（Blocked）</strong>：一个正常运行的线程因为特殊原因被暂停执行，就进入阻塞状态（Blocked）。阻塞时线程不能进入就绪对流排队，必须等到引起阻塞的原因消除，才能重新进入队列排队。引起阻塞的方法很多，sleep() 和 wait() 是两个常用的阻塞方法</li>
<li><strong>中断线程</strong>：<ul>
<li><code>void interrupt()</code>：向一个线程发送一个中断请求，并把该线程的 interruptd 状态变为 true。中断阻塞线程的场合，会抛出 InterruptException 异常</li>
<li><code>static boolean interrupted()</code>：检测当前线程是否被中断，并重置状态 interrupted 的值。连续调用该方法的场合，第二次调用会返回 false</li>
<li><code>boolean isInterrupted()</code>：检测当前线程是否中断。不改变 interrupted 的值</li>
</ul>
</li>
</ul>
<h1 id="14-2-线程的使用"><a href="#14-2-线程的使用" class="headerlink" title="14.2 线程的使用"></a>14.2 线程的使用</h1><p>在 Java 中线程使用有两种方法：</p>
<ol>
<li><p>继承 <code>Thread</code> 类，重写 <code>run</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>		<span class="comment">//可见 Thread 也是实现了 Runable 接口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 <code>Runable</code> 接口，重写 <code>run</code> 方法</p>
</li>
</ol>
<h2 id="14-2-1-继承Thread类"><a href="#14-2-1-继承Thread类" class="headerlink" title="14.2.1 继承Thread类"></a>14.2.1 继承Thread类</h2><blockquote>
<p>Thread 类是 Java 用于表示线程的类。那么，一个类被定义为其子类，则该类也能用来表示线程</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Type</span>();</span><br><span class="line"> type.start();								<span class="comment">//开始线程</span></span><br><span class="line"> 											<span class="comment">//如果用 run 方法，则还是停留在主线程</span></span><br><span class="line"> 											<span class="comment">//  那样，相当于 串行。执行完毕才继续</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;						<span class="comment">//先继承 Thread 类</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">100</span>);				<span class="comment">//休眠 100 毫秒</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (i++ == <span class="number">10</span>) &#123;					<span class="comment">//i = 10 时停止循环</span></span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关于<code>start()</code> 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    start0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;					<span class="comment">//start0 是 native。即，底层方法</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>start()</code> 方法调用了一个 <code>start0()</code> 底层方法</li>
<li><code>start0()</code> 是本地方法，由 JVM 调用，底层是 c&#x2F;c++ 实现</li>
<li>真正的多线程效果，是 <code>start0()</code>，而不是 <code>run()</code></li>
<li><code>start()</code> 方法调用 <code>start0() </code>方法后，该线程不一定会立刻执行，只是将线程变成了可运行状态。具体何时运行，由 CPU 统一调度</li>
</ol>
<h2 id="14-2-2-实现Runable接口"><a href="#14-2-2-实现Runable接口" class="headerlink" title="14.2.2 实现Runable接口"></a>14.2.2 实现Runable接口</h2><blockquote>
<p>Runnable 是 Java 用以实现线程的接口。从根本上将，任何实现线程的类都必须实现该接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">Runnable</span> <span class="variable">type</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Type</span>();					<span class="comment">//Runable 没有 start()方法</span></span><br><span class="line"> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(type);				<span class="comment">//所以，这里使用了 静态代理</span></span><br><span class="line"> thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Type</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;				<span class="comment">//这部分和 Thread 相似</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">         System.out.println(i &lt;&lt; i);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">100</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (++i &gt; <span class="number">15</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关于静态代理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runable</span> &#123;&#125;</span><br><span class="line">	...	</span><br><span class="line">	<span class="keyword">private</span> Runnable target;</span><br><span class="line">	...</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;	<span class="comment">//构造器</span></span><br><span class="line">     init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">     								<span class="comment">//这句话可以先理解为 this.target = target;</span></span><br><span class="line"> &#125;</span><br><span class="line">	...</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">         target.run();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于，先创建了一个新线程，然后在新线程中调用 run 方法</span></span><br></pre></td></tr></table></figure>
<h2 id="14-2-3-继承Thread和实现Runable的区别"><a href="#14-2-3-继承Thread和实现Runable的区别" class="headerlink" title="14.2.3 继承Thread和实现Runable的区别"></a>14.2.3 继承Thread和实现Runable的区别</h2><ol>
<li>从 Java 设计来看，两者本质上没有区别。Thread 类本身就实现了 Runable 接口</li>
<li>实现 Runable 接口的方式更加适合多个线程共享一个资源的情况，且避免了单继承的限制。建议使用。</li>
</ol>
<h2 id="14-2-4-线程中止"><a href="#14-2-4-线程中止" class="headerlink" title="14.2.4 线程中止"></a>14.2.4 线程中止</h2><ol>
<li>当线程结束后，会自动退出</li>
<li>还可以通过使用变量来控制 <code>run</code> 方法退出的方式来停止线程，即 通知方式。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (active) &#123;					<span class="comment">//这个场合，只要外部控制 active 即可</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">1</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     move();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="14-2-5-线程的常用方法"><a href="#14-2-5-线程的常用方法" class="headerlink" title="14.2.5 线程的常用方法"></a>14.2.5 线程的常用方法</h2><ul>
<li>setName(name)：设置线程名称，使之与参数 name 相同</li>
<li>getName()：返回线程名称</li>
<li>start()：线程开始执行。JVM 调用 start0 方法该方法会创建新的线程，新线程调用 run。</li>
<li>run()：到下面玩跑步就是简单的方法调用，不会产生新线程。</li>
<li>setPriority(int priority)：更改线程优先级getPriority()：获取线程优先级priority 范围：每个线程都有一个优先级。Java 线程调度采用如下优先级策略：<ul>
<li>MAX_PRIORITY：最高优先级（10）</li>
<li>MIN_PRIORITY：最低优先级（1）</li>
<li>NORM_PRIORITY：不高不低，真是好极了的优先级（5）</li>
<li>优先级高的先执行，优先级低的后执行</li>
<li>每个线程创建时会被自动分配一个优先级。默认的场合，继承父类优先级</li>
<li>任务紧急的线程，优先级较高</li>
<li>同优先级线程按 “先进先出” 原则调度</li>
</ul>
</li>
<li>sleep(int millsecond)：让线程休眠指定的时间该方法是 Thread 类的静态方法，可以直接调用</li>
<li>interrupt()：中断线程（不是 中止）</li>
<li>yield()：线程的礼让。让出 CPU 让其他线程执行。因为礼让的时间不确定，所以不一定礼让成功。本质是 RUNNING 切换为 READY，即让当前线程放弃执行权</li>
<li>wait()：导致当前线程等待直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法才能唤醒此线程notify()、notifyAll()：唤醒因 wait() 阻塞的线程。这些方法（wait()、notify()、notifyAll()）只能在 synchrnized 方法或代码块中调用</li>
<li>join()：线程的插队。插队的线程一旦插入成功，则必定先执行完插队线程的所有任务将导致其他线程的等待，直到 join() 方法的线程结束join(long timeout)：join，但是时间到后也能结束其他线程的等待</li>
<li>isAlive()：测试当前线程是否在活动</li>
<li>Thread.currentThread()：引用当前运行中的线程</li>
</ul>
<h2 id="14-2-6-用户线程和守护线程"><a href="#14-2-6-用户线程和守护线程" class="headerlink" title="14.2.6 用户线程和守护线程"></a>14.2.6 用户线程和守护线程</h2><ul>
<li>用户线程：也叫工作线程。当线程任务执行完毕或通知方式结束</li>
<li>守护线程：一般是为工作线程服务的。当所有线程结束，守护线程自动结束常见的守护线程：垃圾回收机制<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thraed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(bullet);</span><br><span class="line">thread.setDeamon(<span class="literal">true</span>);							<span class="comment">//这样，子线程被设置为主线程的守护线程</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-2-7-线程的生命周期"><a href="#14-2-7-线程的生命周期" class="headerlink" title="14.2.7 线程的生命周期"></a>14.2.7 线程的生命周期</h2><p>线程的状态有</p>
<ul>
<li>NEW：尚未启动</li>
<li>RUNNABLE：在 JVM 中执行的线程可细分为 READY 和 RUNNING</li>
<li>BLOCKED：被阻塞等待监视器锁定的线程</li>
<li>WAITING：正等待另一个线程执行特定动作的线程</li>
<li>TIMED_WAITING：正等待另一个线程执行特定动作达到等待时间的线程</li>
<li>TERMINATED：已退出的线程</li>
</ul>
<h1 id="14-3-线程的互斥"><a href="#14-3-线程的互斥" class="headerlink" title="14.3 线程的互斥"></a>14.3 线程的互斥</h1><blockquote>
<p>在多线程编程，一些敏感数据不允许被多个线程同时访问。此时就用同步访问技术，保证数据在任意时刻，最多有一个线程同时访问，以保证数据的完整性。<br>也可以这样理解：线程同步，即当有一个线程对内存进行操作时，其他线程都不能对这个内存地址进行操作（被阻塞），直到该线程完成操作，再让下一线程进行操作。</p>
</blockquote>
<h2 id="14-3-1-互斥锁"><a href="#14-3-1-互斥锁" class="headerlink" title="14.3.1 互斥锁"></a>14.3.1 互斥锁</h2><blockquote>
<p>在 Java 语言中，引入了 “对象互斥锁” 的概念，也称为监视器，来保证共享数据操作的完整性<br>每个对象都对应一个可称为 “互斥锁” 的标记，这个标记用来保证在任一时刻都只能有一个线程访问对象。<br>Java 语言中，有 2 种方式实现互斥锁：</p>
<ul>
<li>用关键字 volatile 声明一个共享数据（变量）。一般很少使用该关键字</li>
<li>用关键字 synchronized 声明共享数据的一个方法或一个代码</li>
</ul>
</blockquote>
<p>同步的局限性：导致程序的执行效率要降低。</p>
<blockquote>
<p>非静态的对象，同步方法的锁可以是 this，也可以是其他对象（要求是同一对象）<br>静态对象，同步方法的锁为当前类本身</p>
</blockquote>
<ol>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;		<span class="comment">//得到对象的锁，才能操作同步代码</span></span><br><span class="line">	需要被同步代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一个线程持有锁定标记时，如果另一个线程企图执行该代码块语句，将从对象中索取锁定标记。<br>因为此时该标记不可得，古该线程不能继续执行，而是加入等待队列。<br>程序运行完 synchronized 代码块后，锁定标记会被自动返还。即使该同步代码块执行过程中抛出异常也是如此。一个线程多次调用该同步代码块的场合，也会在最外层执行完毕后正确返还。</p>
</li>
<li><p>放在方法声明中，表示整个方法为同步方法</p>
</li>
</ol>
<p>因为 synchronized 语句的参数必须是 this，因此允许下面这种简洁的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="14-3-2-线程死锁"><a href="#14-3-2-线程死锁" class="headerlink" title="14.3.2 线程死锁"></a>14.3.2 线程死锁</h2><blockquote>
<p>多个线程都占用了对方的资源，不肯相让，就导致了死锁。编程时要避免死锁的产生。</p>
</blockquote>
<ul>
<li>以下操作会释放锁<ol>
<li>当前线程的同步方法、同步代码块执行结束。</li>
<li>当前线程在同步方法、同步代码块中遇到 break、return</li>
<li>当前线程在同步方法、同步代码块中出现了未处理的 Error</li>
<li>当前线程在同步方法、同步代码块中执行了 wait() 方法，当前线程暂停，并释放锁</li>
</ol>
</li>
<li>以下操作不会释放锁<ol>
<li>执行同步方法、同步代码块时，程序调用 Thread.sleep() 或 Thread.yield() 方法暂停当前线程的执行，不会释放锁</li>
<li>线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁所以，应尽量避免使用 suspend() 和 resume() 来控制线程</li>
</ol>
</li>
</ul>
<h1 id="14-4-线程的同步"><a href="#14-4-线程的同步" class="headerlink" title="14.4 线程的同步"></a>14.4 线程的同步</h1><blockquote>
<p>Java 中，可以使用 wait()、notify()、notifyAll() 来协调线程间的运行速度关系。这些方法都被定义在 java.lang.Object 中<br>Java 中的每个对象实例都有两个线程队列和它相连。一个用以实现等待锁定标志的线程，另一个用来实现 wait() 和 notify() 的交互机制</p>
</blockquote>
<ul>
<li>wait()：让当前线程释放所有其持有的 “对象互斥锁”，进入等待队列</li>
<li>notify()、notifyAll()：唤醒一个或所有在等待队列中等待的线程，并将他们移入同一个等待 “对象互斥锁” 的队列。执行这些方法时如果没有等待中的线程，则其不会生效，也不会被保留到以后再生效<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key.value == <span class="number">0</span>) key.wait();</span><br><span class="line">    key.value--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (key) &#123;</span><br><span class="line">    key.value++;</span><br><span class="line">    key.nitifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为调用这些方法时必须持有对象的 “对象互斥锁”，所以上述方法只能在 synhronized 方法或代码块中执行。</li>
</ul>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>15. IO流</title>
    <url>/2022/09/11/JavaSE/15.%20IO%E6%B5%81/</url>
    <content><![CDATA[<h1 id="15-1-文件"><a href="#15-1-文件" class="headerlink" title="15.1 文件"></a>15.1 文件</h1><blockquote>
<p>文件就是保存数据的地方。<br>文件流：文件 在 程序 中是以 流 的形式来操作的。<br>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源到程序的路径<br>输出流：数据从程序到数据源的路径</p>
</blockquote>
<h2 id="15-1-1-常用的文件操作"><a href="#15-1-1-常用的文件操作" class="headerlink" title="15.1.1 常用的文件操作"></a>15.1.1 常用的文件操作</h2><blockquote>
<p>Java 提供了 File 类，用于处理文件相关的操作</p>
</blockquote>
<ol>
<li>创建文件对象相关构造器和方法</li>
</ol>
<ul>
<li><p><code>new File(String pathname)</code>：根据路径创建一个 File 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path1</span> <span class="operator">=</span> <span class="string">&quot;d:/test.jpg&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">path2</span> <span class="operator">=</span> <span class="string">&quot;d:\\test.jpg&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path1);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path2);			<span class="comment">//此时只是在内存中产生了一个对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>new File(File parent, String child)</code>：根据父目录文件 + 子路径构建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">parentFile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">fileName1</span> <span class="operator">=</span> <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile1, fileName1);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>new File(String parent, String child)</code>：根据父路径 + 子路径构建</p>
</li>
<li><p><code>creatNewFile()</code>：创建新文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> file.createNewFile();				<span class="comment">//这个场合，内存对象才写入磁盘</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>获取文件相关信息</li>
</ol>
<ul>
<li><code>getName()</code>：获取名称</li>
<li><code>getAbsolutePath()</code>：获取文件绝对路径</li>
<li><code>getParent()</code>：获取文件父级目录</li>
<li><code>long length()</code>：获取文件大小（字节）</li>
<li><code>exists()</code>：文件是否存在</li>
<li><code>isFile()</code>：是不是一个文件</li>
<li><code>isDirectory()</code>：是不是一个目录</li>
<li><code>isAbsolute()</code>：是不是绝对路径</li>
<li><code>canRead()</code>：是否可读canWirte()：是否可写</li>
<li><code>long lastModified()</code>：最后修改时间</li>
<li><code>String[] list()</code>：列出符合模式的文件名</li>
</ul>
<ol start="3">
<li>目录的操作和文件删除</li>
</ol>
<ul>
<li><code>mkdir</code>：创建一级目录</li>
<li><code>mkdirs</code>：创建多级目录</li>
<li><code>delete</code>：删除空目录或文件</li>
<li><code>boolean renameTo(File newName)</code>：更改文件名</li>
</ul>
<p>其实目录也属于文件<br>注意事项：</p>
<ul>
<li>File 类可以获取文件的各种相关属性，可以对其进行改名，甚至删除。但除了文件名外的属性没有修改方法</li>
<li>File 类可以用来描述一个目录，但不能改变目录名，也不能删除目录</li>
</ul>
<h1 id="15-2-IO流"><a href="#15-2-IO流" class="headerlink" title="15.2 IO流"></a>15.2 IO流</h1><ol>
<li>I &#x2F; O 是 Input &#x2F; Output 的缩写。IO 技术是非常实用的技术，用于处理数据传输。如 读 &#x2F; 写 文件，网络通讯等。</li>
<li>Java 程序中，对于数据的 输入 &#x2F; 输出 操作以 “流（stream）”的方式进行</li>
<li>java.io 包下提供了各种 “流” 类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li>
<li>输入（input）：读取外部数据（磁盘、光盘、网络数据等）到程序（内存）中</li>
<li>输出（output）：将程序（内存）数据输出到外部存储</li>
</ol>
<h2 id="15-2-1-IO流的分类"><a href="#15-2-1-IO流的分类" class="headerlink" title="15.2.1 IO流的分类"></a>15.2.1 IO流的分类</h2><ul>
<li>按操作数据单位不同分为：<ul>
<li>字节流（8 bit）：二进制文件用该方法，能确保文件无损</li>
<li>字符流（按照字符，字符的字节数由编码决定）：文本文件，效率更高</li>
</ul>
</li>
<li>按数据流的流向不同分为：<ul>
<li>输入流：读取外部数据（磁盘、光盘、网络数据等）到程序（内存）中</li>
<li>输出流：将程序（内存）数据输出到外部存储</li>
</ul>
</li>
<li>按流的角色不同分为：<ul>
<li>节点流</li>
<li>处理流 &#x2F; 包装流<table>
<thead>
<tr>
<th><strong>Σ(っ °Д °;)っ</strong></th>
<th><strong>字节流</strong></th>
<th><strong>字符流</strong></th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p>Java 的 IO流 总共涉及 40多个类，实际上都是上述 4 类的抽象基类派生的<br>由这 4 个类派生的子类名称都是以其父类名作为子类名后缀</p>
<h2 id="15-2-2-IO流的常用类"><a href="#15-2-2-IO流的常用类" class="headerlink" title="15.2.2 IO流的常用类"></a>15.2.2 IO流的常用类</h2><h3 id="15-2-2-1-FileInputStream文件字节输入流"><a href="#15-2-2-1-FileInputStream文件字节输入流" class="headerlink" title="15.2.2.1 FileInputStream文件字节输入流"></a>15.2.2.1 <code>FileInputStream</code>文件字节输入流</h3><ul>
<li><p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FileInputStream</span>(File file);				<span class="comment">//通过一个 File 的路径指定创建</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileInputStream</span>(String path);			<span class="comment">//通过一个路径指定创建</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FileDescriptor fdObj);	<span class="comment">//通过文件描述符创建</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法:</p>
</li>
<li><p><code>available()</code>：返回目前可以从流中读取的字节数实际操作时，读取的字节数可能大于这个返回值</p>
</li>
<li><p><code>close()</code>：关闭文件输入流，释放资源</p>
</li>
<li><p><code>finalize()</code>：确保在不引用文件输入流时调用其 close() 方法</p>
</li>
<li><p><code>getChannel()</code>：返回与此流有关的唯一的 FileChannel 对象</p>
</li>
<li><p><code>getFD()</code>：返回描述符</p>
</li>
<li><p><code>read()</code>：从该输入流中读取一个数据字节如果没有输入可用，该方法会被阻止。返回 -1 的场合，说明到达文件的末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\test&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> read;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"> <span class="keyword">while</span> ((read = fileInputStream.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">     System.out.print((<span class="type">char</span>) read);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     fileInputStream.close();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;										<span class="comment">//真 TM 复杂。throw 了算了</span></span><br></pre></td></tr></table></figure>
<p><code>read(byte[] b)</code>：从该输入流中把最多 b.length 个字节的数据读入一个 byte 数组<br>读取正常的场合，返回实际读取的字节数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];					<span class="comment">//一次读取 8 字节</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"> <span class="keyword">while</span> ((read = fileInputStream.read(b)) != -<span class="number">1</span>)&#123;</span><br><span class="line">     System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, read));</span><br><span class="line">     								<span class="comment">//这一句看不懂请看[12.2 - 4]</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">catch</span> </span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>read(byte[] b, int off, int len)</code>：从该输入流中读取 len 字节数据，从数组下标 off 处起写入</p>
</li>
<li><p><code>skip(long n)</code>：从该输入流中跳过并去丢弃 n 个字节的数据</p>
</li>
<li><p><code>mark(int markArea)</code>：标记数据量的当前位置，并划出一个缓冲区。缓冲区大小至少为 <code>markAreareset()</code>：将输入流重新定位到对此流最后调用 mark() 方法时的位置</p>
</li>
<li><p><code>markSupported()</code>：测试数据流是否支持 mark() 和 reset() 操作</p>
</li>
</ul>
<h3 id="15-2-2-2-FileOutputStream-文件字节输出流"><a href="#15-2-2-2-FileOutputStream-文件字节输出流" class="headerlink" title="15.2.2.2 FileOutputStream 文件字节输出流"></a>15.2.2.2 <code>FileOutputStream</code> 文件字节输出流</h3><ul>
<li><p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(File file);			<span class="comment">//通过一个 File 的路径指定创建</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(File file, <span class="type">boolean</span> append);			</span><br><span class="line">							<span class="comment">//append = false，写入采用 覆盖原文件 方式</span></span><br><span class="line">							<span class="comment">//append = true 的场合，写入采用 末尾追加 方式</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(String path);			<span class="comment">//通过一个路径指定创建</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(String path, <span class="type">boolean</span> append);			</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileDescriptor fdObj);	<span class="comment">//通过文件描述符创建</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法：</p>
</li>
<li><p><code>close()</code>：关闭文件输入流，释放资源</p>
</li>
<li><p><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节</p>
</li>
<li><p><code>finalize()</code>：确保在不引用文件输入流时调用其 close() 方法</p>
</li>
<li><p><code>getChannel()</code>：返回与此流有关的唯一的 FileChannel 对象</p>
</li>
<li><p><code>getFD()</code>：返回描述符</p>
</li>
<li><p><code>write(byte[] b)</code>：将 b.length 个字节从指定 byte 数组写入此文件输出流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\test1&quot;</span>);</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line"> 									<span class="comment">//此时，若文件不存在会被创建</span></span><br><span class="line"> fileOutputStream.write(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Melody&quot;</span>;</span><br><span class="line"> fileOutputStream.write(str.getBytes());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>write(byte[] b， int off, int len)</code>：将指定 byte 数组中下标 off 开始的 len 个字节写入此文件输出流</p>
</li>
<li><p><code>write(int b)</code>：将指定字节写入此文件输出流</p>
</li>
</ul>
<h3 id="15-2-2-3-FileReader-文件字符输入流"><a href="#15-2-2-3-FileReader-文件字符输入流" class="headerlink" title="15.2.2.3 FileReader 文件字符输入流"></a>15.2.2.3 <code>FileReader</code> 文件字符输入流</h3><blockquote>
<p>与其他程序设计语言使用 ASCII 码不同，Java 使用 Unicode 码表示字符串和字符。ASCII 码的字符占用 1 字节，可以认为一个字符就是一个字节。但 Unicode 码用 2 字节表示 1 个字符，此时字符流和字节流就不相同。</p>
</blockquote>
<ul>
<li><p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FileRaeder</span>(File file);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileRaeder</span>(String string);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法：</p>
</li>
</ul>
<p><code>read()</code>：读取单个字符。<br><code>read(char[])</code>：批量读取多个字符到数组。</p>
<h3 id="15-2-2-3-FileWriter文件字符输出流"><a href="#15-2-2-3-FileWriter文件字符输出流" class="headerlink" title="15.2.2.3 FileWriter文件字符输出流"></a>15.2.2.3 <code>FileWriter</code>文件字符输出流</h3><ul>
<li><p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FileWriter</span>(File path);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileWriter</span>(String path2);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileWriter</span>(File path3, <span class="type">boolean</span> append);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">FileWriter</span>(String path4, <span class="type">boolean</span> append);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法：</p>
</li>
<li><p><code>write(int)</code>：写入单个字符</p>
</li>
<li><p><code>write(char[])</code>：写入指定数组</p>
</li>
<li><p><code>write(char[], off, len)</code>：写入指定数组的指定部分</p>
</li>
<li><p><code>write(string)</code>：写入字符串</p>
</li>
<li><p><code>write(string, off, len)</code>：写入字符串的指定部分</p>
</li>
<li><p><code>flush()</code>：刷新该流的缓冲。如果没有执行，内容就不会写入文件</p>
</li>
<li><p><code>close()</code>：等于 flush() + 关闭</p>
</li>
</ul>
<p><strong>注意！FileWriter 使用后，必须关闭（close）或刷新（flush），否则无法真正写入</strong></p>
<h3 id="15-2-2-4-转换流InputStreamReader-和-OutputStreamReader"><a href="#15-2-2-4-转换流InputStreamReader-和-OutputStreamReader" class="headerlink" title="15.2.2.4 转换流InputStreamReader 和 OutputStreamReader"></a>15.2.2.4 转换流<code>InputStreamReader</code> 和 <code>OutputStreamReader</code></h3><ol>
<li>InputStreamReader 是 Reader 的子类。可以把 InputStream（字节流）转换成 Reader（字符流）</li>
<li>OutputStreamWriter 是 Writer 的子类。可以把 OutputStream（字节流）转换成 Writer（字符流）</li>
<li>处理纯文本数据时，如果使用字符流效率更高，并能有效解决中文问题，建议将字节流转换成字符流。</li>
<li>可以在使用时指定编码格式（UTF -8、GBK 等）</li>
</ol>
<ul>
<li>构造器<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">										<span class="comment">//传入 字节流 和 编码类型</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bufferedreader</span>(isr);</span><br><span class="line">										<span class="comment">//用另一个处理流包装</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="15-2-3-节点流和处理流"><a href="#15-2-3-节点流和处理流" class="headerlink" title="15.2.3 节点流和处理流"></a>15.2.3 节点流和处理流</h2><ol>
<li>节点流：从一个特定数据源读写数据。</li>
<li>处理流（包装流）：是 “连接” 在已存在的流（节点流或处理流）上，为程序提供更强大的读写功能。</li>
</ol>
<p><strong>节点流和处理流的区别</strong></p>
<ol>
<li>节点流是 底层流 &#x2F; 低级流。直接和数据源相接。</li>
<li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法完成输入输出</li>
<li>处理流对节点流进行包装，使用了修饰器设计模式。不会直接与数据源相连</li>
<li>处理流的功能主要体现在<ul>
<li>性能的提高：以增加缓冲的方式提高输入输出的效率</li>
<li>操作的便捷：处理流可能提供了一系列便捷方法来一次性输入大量数据，使用更加灵活方便</li>
</ul>
</li>
<li>关闭时关闭外层流即可</li>
</ol>
<h3 id="15-2-3-1-缓冲区流"><a href="#15-2-3-1-缓冲区流" class="headerlink" title="15.2.3.1 缓冲区流"></a>15.2.3.1 缓冲区流</h3><p>缓冲区流是一种包装流。缓冲区字节流有 BufferedInputStream 和 BufferedOutputStream；缓冲区字符流有 BufferedWriter 和 BufferedReader。他们是在数据流上加了一个缓冲区。读写数据时，数据以块为单位进入缓冲区，其后的读写操作则作用于缓冲区。<br>这种方式能降低不同硬件设备间的速度差异，提高 I&#x2F;O 效率。<br>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);					<span class="comment">//传入一个 Reader</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader, <span class="number">1024</span>);			<span class="comment">//传入 Reader 并指定缓冲区大小</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer);					<span class="comment">//传入一个 Writer</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer, <span class="number">1024</span>);			<span class="comment">//传入 Writer 并指定缓冲区大小</span></span><br><span class="line">											<span class="comment">//追加还是覆盖，取决于 writer</span></span><br></pre></td></tr></table></figure>
<p>方法：<br><code>bufferedReader.readLine()</code>：按行读取（不含换行符）。<br>会返回一个字符串。返回 null 时，表示读取完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> (line = bufferedReader.readLine() != <span class="literal">null</span>)&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">bufferedReader.close();</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bufferedWriter.write(String str)</code>：插入字符串</li>
<li><code>bufferedWriter.newLine()</code>：插入一个（和系统相关的）换行</li>
</ul>
<h3 id="15-2-3-2-数据流"><a href="#15-2-3-2-数据流" class="headerlink" title="15.2.3.2 数据流"></a>15.2.3.2 数据流</h3><blockquote>
<p>除了字节或字节数组外，处理的数据还有其他类型。为解决此问题，可以使用 DataInputStream 和 DataOutputStream。它们允许通过数据流来读写 Java 基本类型，如布尔型（boolean）、浮点型（float）等</p>
</blockquote>
<p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">DataInputStream</span>(inputStream);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(outputStream);</span><br></pre></td></tr></table></figure>
<p>方法：</p>
<ul>
<li><code>byte readByte()</code>：读取下一个 byte</li>
<li><code>int readInt()</code>、<code>double readDouble()</code>、<code>String readUTF()</code>……</li>
<li><code>void writeByte(byte b)</code>：写入一个 byte</li>
<li><code>void writeInt(int n)</code>、<code>void writeUTF(String str)</code>……虽然有对字符串的读写方法，但应避免使用这些方法，转而使用字符输入&#x2F;输出流。</li>
</ul>
<h3 id="15-2-3-3-对象流"><a href="#15-2-3-3-对象流" class="headerlink" title="15.2.3.3 对象流"></a>15.2.3.3 对象流</h3><p>当我们保存数据时，同时也把 数据类型 或 对象 保存。<br>以上要求，就是能够将 基本数据类型 或 对象 进行 序列化·反序列化 操作<br><strong>序列化和反序列化</strong></p>
<ol>
<li>把对象转成字符序列的过程称为序列化。保存数据时，保存数据的值和数据类型</li>
<li>把字符序列转成对象的过程称为反序列化。恢复数据时，恢复数据的值和数据类型</li>
<li>需要让某个对象支持序列化机制，则必须让其类是 可序列化的。由此，该类必须实现下列接口之一<ul>
<li><code>Serializable</code>：推荐。因为是标记接口，没有方法</li>
<li><code>Externalizable</code>：该接口有方法需要实现</li>
</ul>
</li>
</ol>
<p><strong>transient关键字</strong></p>
<ol>
<li>有一些对象状态不具有可持久性（如 Thread 对象或流对象），这样的成员变量必须用 transient 关键字标明。任何标有 transient 关键字的成员变量都不会被保存。</li>
<li>一些需要保密的数据，不应保存在永久介质中。为保证安全，这些变量前应加上 transient 关键字。</li>
</ol>
<ul>
<li><p>构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(InputStream inputStream);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(OutputStream outputStream);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法：</p>
</li>
</ul>
<p>反序列化顺序需要和序列化顺序一致，否则出现异常。</p>
<ul>
<li>writeInt(Integer)：写入一个 int</li>
<li>readInt()：读取一个 int</li>
<li>writeBoolean(Boolaen)：写入一个 boolean</li>
<li>readBoolean()：读取一个 boolean</li>
<li>writeChar(Character)：写入一个 char</li>
<li>readChar()：读取一个 char</li>
<li>writeDouble(Double)：写入一个 double</li>
<li>readDouble()：读取一个 double</li>
<li>writeUTF(String)：写入一个 String</li>
<li>readUTF()：读取一个 String</li>
<li>writeObject(Serializable)：写入一个 Obj</li>
<li>readObject()：读取一个 Obj读取的场合，</li>
<li>如果想要调用方法，需要向下转型。为此，需要该类其引入，或将类的定义拷贝到可以引用的位置。</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><p>读写顺序要一致</p>
</li>
<li><p>实现序列化或反序列化的对象，要实现 Serializable 或 Externalizable 接口</p>
</li>
<li><p>序列化的类中建议添加 SerialVersionUID 以提高版本兼容性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br></pre></td></tr></table></figure>
<p>有此序列号的场合，后续修改该类，系统会认为只是版本修改，而非新的类</p>
</li>
<li><p>序列化对象时，默认将其中所有属性进行序列化（除了 static 和 tansient 修饰的成员）</p>
</li>
<li><p>序列化对象时，要求其属性也实现序列化接口</p>
</li>
<li><p>序列化具备可继承性。某类若实现可序列化，则其子类也可序列化</p>
</li>
</ol>
<h3 id="15-2-3-4-标准输出-x2F-输入流"><a href="#15-2-3-4-标准输出-x2F-输入流" class="headerlink" title="15.2.3.4 标准输出 &#x2F; 输入流"></a>15.2.3.4 标准输出 &#x2F; 输入流</h3><table>
<thead>
<tr>
<th><strong>Σ( ° △ °lll）</strong></th>
<th><strong>编译类型</strong></th>
<th><strong>运行类型</strong></th>
<th><strong>默认设备</strong></th>
</tr>
</thead>
<tbody><tr>
<td>System.in：标准输入</td>
<td>InputStream</td>
<td>BufferedInputStream</td>
<td>键盘</td>
</tr>
<tr>
<td>System.out：标准输出</td>
<td>PaintStream</td>
<td>PaintStream</td>
<td>显示器</td>
</tr>
</tbody></table>
<h3 id="15-2-3-5-打印流-PaintStream-和-PaintWriter"><a href="#15-2-3-5-打印流-PaintStream-和-PaintWriter" class="headerlink" title="15.2.3.5 打印流 PaintStream 和 PaintWriter"></a>15.2.3.5 打印流 <code>PaintStream</code> 和 <code>PaintWriter</code></h3><blockquote>
<p>打印流只有输出流，没有输入流</p>
</blockquote>
<ol>
<li>PaintStream 是 OutputStream 的子类。PaintWriter 是 Writer 的子类。</li>
<li>默认情况下，System.out 输出位置是 标准输出（即：显示器）修改默认输出位置：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(path));</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="15-2-3-6-Properties类"><a href="#15-2-3-6-Properties类" class="headerlink" title="15.2.3.6 Properties类"></a>15.2.3.6 <code>Properties</code>类</h3><ol>
<li><p>Properties 是专门用于读写配置文件的集合类底层维护了一个 Entry 数组</p>
</li>
<li><p>配置文件格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">键=值</span><br><span class="line">键=值</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p><strong>注意：键值对不需要空格，值不需要引号（值默认 String）</strong></p>
</li>
<li><p>常见方法</p>
</li>
</ol>
<p><code>load(InputStream)</code><br><code>load(Reader)</code>：加载配置文件的键值对到 Properties 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\data.data&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><code>list(PaintStream)</code><br><code>list(PaintWriter)</code>：将数据显示到指定设备</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">properties.list(System.out);			<span class="comment">//在控制台显示</span></span><br></pre></td></tr></table></figure>
<p><code>getProperty(key)</code>：根据键获取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">properties.get(<span class="string">&quot;IQ&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>setProperty(key, value)</code>：设置键值对到 Properties 对象<br>如果没有该 key，就是创建。如有，就是替换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">properties.set(<span class="string">&quot;IQ&quot;</span>, <span class="number">0</span>);</span><br><span class="line">properties.set(<span class="string">&quot;Balance&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>store(Writer, String)</code><br><code>store(OutputStream, String)</code>：把 Properties 中的键值对存储到配置文件。<br>后面的 String 是注释。如有，会被用 # 标记并写在文件最上方。注释可以为 null。<br>IDEA 中，如果含有中文，会储存为 unicode 码</p>
<h3 id="15-2-3-7-随机访问文件"><a href="#15-2-3-7-随机访问文件" class="headerlink" title="15.2.3.7 随机访问文件"></a>15.2.3.7 随机访问文件</h3><blockquote>
<p>程序阅读文件时不仅要从头读到尾，还要实现每次在不同位置进行读取。此时可以使用 RandomAccessFile</p>
</blockquote>
<p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(String name, String mode);		<span class="comment">//通过文件名</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(File file, String mode);		<span class="comment">//通过文件对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数 mode 决定以只读方式 <code>mode = &quot;r&quot; </code>还是读写方式 <code>mode = &quot;rw&quot;</code> 访问文件。</p>
</blockquote>
<p>方法：</p>
<ul>
<li><code>long getFilePointer()</code>：返回文档指针的当前位置</li>
<li><code>void seek(long pos)</code>：将文档指针置于指定的绝对位置 pos文档指针的位置从文档开始的字符处开始计算，pos &#x3D; 0L 表示文档的开始</li>
<li><code>long length()</code>：返回文件长度</li>
</ul>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 变量</title>
    <url>/2022/09/11/JavaSE/2.%20%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="2-1-变量介绍"><a href="#2-1-变量介绍" class="headerlink" title="2.1 变量介绍"></a>2.1 变量介绍</h1><blockquote>
<p><strong>变量</strong>：<strong>变量</strong>是<strong>程序</strong>的<strong>基本组成单位</strong><br><strong>变量的三个基本要素</strong>：<strong>类型</strong> +** 名称** + <strong>值</strong><br>示例：int a &#x3D; 1 类型 int 名称 a 值 1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> c=<span class="number">1</span>,d;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>变量的使用注意事项</strong></li>
</ul>
<ol>
<li><strong>变量</strong>表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如<code>int</code>有 <code>4 byte</code>，而 <code>double </code>有 <code>8 byte</code>。</li>
<li>该区域有自己的<strong>名称</strong> <strong>变量名</strong> 和<strong>类型 数据类型</strong></li>
<li>变量必须<strong>先声明，后使用。</strong></li>
<li>变量<strong>在同一作用域内不能重名。</strong></li>
<li>该区域的数据 、 值可以在同一类型范围内变化。</li>
<li>变量的<strong>三个基本要素</strong>：类型 + 名称 + 值</li>
</ol>
<h1 id="2-2-号的使用"><a href="#2-2-号的使用" class="headerlink" title="2.2  +号的使用"></a>2.2  +号的使用</h1><ol>
<li><strong>当左右两边都是数值型，做加法运算</strong></li>
<li><strong>当左右两边任意一方为字符串，做拼接运算</strong></li>
<li><strong>运算顺序是从左到右的</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> + <span class="string">&quot;Hello&quot;</span> + <span class="number">2</span>);			<span class="comment">// 输出 1Hello2</span></span><br><span class="line">System.out.println(<span class="number">1</span> + <span class="number">1</span>);						<span class="comment">// 输出 2</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>);   		<span class="comment">// 输出 HelloWorld</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h1><blockquote>
<p><strong>基本数据类型</strong></p>
</blockquote>
<ul>
<li><p><strong>数值型</strong></p>
<ul>
<li>整数类型：<ul>
<li><code>**byte **</code>**: **占用 1 个字节</li>
<li><code>**short **</code>**: **占用 2 个字节</li>
<li><code>**int **</code>**: **占用 4 个字节</li>
<li><code>**long **</code>**: **占用 8 个字节</li>
</ul>
</li>
<li>浮点数类型(小数类型):<ul>
<li><code>**float**</code>**: **占用 4 个字节</li>
<li><code>**double**</code>** : **占用 8 个字节</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>字符型</strong></p>
<ul>
<li><code>**char**</code> :  存放单个字符，占用 2 字节</li>
</ul>
</li>
<li><p><strong>布尔型</strong></p>
<ul>
<li><code>**boolean**</code> : 存放<code>**true(真)**</code>、<code>**false(假)**</code> 。占用 1 个字节<blockquote>
<p><strong>引用数据类型(复合数据类型)</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>**类 : **<code>**class**</code></p>
</li>
<li><p><strong>接口 ：</strong><code>**interface**</code></p>
</li>
<li><p><strong>数组 ：</strong><code>**[ ]**</code></p>
</li>
</ul>
<h1 id="2-4-整数类型"><a href="#2-4-整数类型" class="headerlink" title="2.4 整数类型"></a>2.4 整数类型</h1><blockquote>
<p>用于存放整数值</p>
</blockquote>
<ul>
<li><code>**byte**</code> 占用 <code>**1**</code> 字节，范围<code> -128 ~ 127</code></li>
<li><code>**short **</code>占用<code>**2**</code> 字节，范围<code> -215~215-1</code></li>
<li><code>**int **</code>占用 <code>**4**</code> 字节，范围 <code>-231~231-1</code></li>
<li><code>**long**</code> 占用 <code>**8**</code> 字节，范围 <code>-263~-263-1</code></li>
</ul>
<p><strong>使用细节：</strong></p>
<ol>
<li>Java 各整数类型有固定的范围和字符长度，不受具体 OS（操作系统）影响，以保证 Java 程序的可移植性。</li>
<li>Java 默认整型常量为 int ，要声明 long 型常量必须后加 l 或 L。</li>
<li>从 Java 7 开始，加上前缀 0b 或 0B 就可以写二进制数。</li>
<li>从 Java 7 开始，可以为数字字面添加下划线。这不会影响数字的值，只是为了方便阅读。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0b0010</span>;</span><br><span class="line">n = <span class="number">0b001</span>;</span><br><span class="line">n = <span class="number">100_0_000000</span>;</span><br><span class="line">n = <span class="number">0B0000_0010_1100</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.0F</span>;</span><br></pre></td></tr></table></figure>
如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用 “大数”</li>
</ol>
<h1 id="2-5-浮点类型"><a href="#2-5-浮点类型" class="headerlink" title="2.5 浮点类型"></a>2.5 浮点类型</h1><blockquote>
<p>可以表示一个小数</p>
</blockquote>
<ul>
<li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 <code>4</code> 字节，范围约 <code>-3.403E38 ~ 3.403E38</code></li>
<li><code>double</code> 双精度（15 位有效数字），占用 <code>8</code> 字节，范围约 <code>-1.798E308 ~ 1.798E308</code></li>
</ul>
<p><em>浮点数在机器中存放形式为：浮点数 &#x3D; 符号位 + 指数位 + 尾数位</em><br><em><strong>因此，尾数部分可能丢失，造成精度损失。换言之，小数都是近似值</strong></em></p>
<h2 id="2-5-1-使用细节"><a href="#2-5-1-使用细节" class="headerlink" title="2.5.1 使用细节"></a>2.5.1 使用细节</h2><ol>
<li><p>与整数类型相似，有固定的范围和字符长度，不受具体 OS（操作系统）影响。</p>
</li>
<li><p>Java 默认浮点常量为<code> double</code> ，要声明 <code>float </code>型常量必须后加 ”f“ 或 ”F“</p>
</li>
<li><p>浮点型常量有两种表示形式</p>
<blockquote>
<p>十进制数形式：5.13、315.4F、.414<br>科学计数法：5.12e2 即[5.12 × 102]、5.12E-2 即[5.12 &#x2F; 102]</p>
</blockquote>
</li>
<li><p>通常情况下，应该使用 <code>double</code> 类型，以其更为精确。</p>
</li>
<li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相对判断时，要小心。（因为**<em>小数都是近似值</em>**）</p>
</li>
</ol>
<p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Math.abs(num1 - num2) &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;插值范围内认为相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>特殊的浮点类型常量</p>
<ul>
<li><strong>正无穷大</strong>：<code>Float.POSITIVE_INFINITY</code>、<code>Double.POSITIVE_INFINITY</code>（浮点数运算中）一个正数除以 0，会得到该值</li>
<li><strong>负无穷大</strong>：<code>Float.NEGATIVE_INFINITY</code>、<code>Double.NEGATIVE_INFINITY</code>（浮点数运算中）一个负数除以 0，会得到该值</li>
<li><strong>0 &#x2F; 0</strong>：<code>Float.NaN</code>、<code>Double.NaN</code>（浮点数运算中）0 除以 0，会得到该值</li>
<li><strong>最大、最小值</strong>：<code>Float.MAX_VALUE</code>、<code>Double.MIN_VALUE</code></li>
</ul>
</li>
<li><p>不能用运算符来比较特殊值，而要用特别的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0.0</span> / <span class="number">0</span>;</span><br><span class="line">System.out.println(num == Double.NaN);			<span class="comment">// &lt;——— 始终为 false。不能如此比较</span></span><br><span class="line">System.out.println(Double.isNaN(num));			<span class="comment">// &lt;——— 判断是否是 NaN</span></span><br><span class="line">num = <span class="number">1.0</span> / <span class="number">0</span>;</span><br><span class="line">System.out.println(Double.isInfinite(num));		<span class="comment">// &lt;——— 是否是无穷大</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于不同处理器寄存浮点数的策略可能不同，浮点数运算的结果也可能不同。</p>
</li>
</ol>
<h1 id="2-6-字符类型"><a href="#2-6-字符类型" class="headerlink" title="2.6 字符类型"></a>2.6 字符类型</h1><blockquote>
<p>可以表示单个字符。(可以存放一个数字，因为其字符是数字编号的。输出时会输出数字对应的字符。”编码的概念“)<br><code>char c1 = &#39;a&#39;; ``  char c2 = &#39;\t&#39;; ``char c3 = &#39;字&#39;; ``char c4 = 99;</code></p>
</blockquote>
<h2 id="2-6-1-使用细节"><a href="#2-6-1-使用细节" class="headerlink" title="2.6.1 使用细节"></a>2.6.1 使用细节</h2><ol>
<li><p>字符常量用单引号括起 <code>&#39; &#39;</code></p>
</li>
<li><p><code>char </code>的本质是一个整数，输出时，输出的是<code>unicode</code>码对应的字符。<a href="https://zh.wikipedia.org/wiki/Unicode">unicode 码查询</a> 。要输出那个整数，用 <code>int</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">System.out.println((<span class="type">int</span>)c1);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>char</code> 是可以进行运算的，其相当于一个整数。**<em>注意与</em><strong>[</strong><em>[2.2]</em><strong>](#dzjeA)</strong><em>的区别。</em>**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注：(int)&#x27;a&#x27; = 97</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;				<span class="comment">// 相当于 char c1 = &#x27;b&#x27;</span></span><br><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);	<span class="comment">// 这个代码输出 98</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span> + <span class="number">1</span>);	<span class="comment">// 这个代码输出 a1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符允许使用转义符（*见 [1.8 Java 转义字符]*）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>转义序列 \u 能出现在引号外。所有这些转义序列会在解析代码前得到处理</strong></p>
</li>
</ol>
<ul>
<li><p>以下字符串是空串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;\u0022+\u0022&quot;</span>;</span><br><span class="line"><span class="comment">// 因为 \u0022 表示引号。该代码等同于以下代码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下注释会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// \u000A is a newline</span></span><br><span class="line"><span class="comment">// 因为 \u000A 是换行符。在解析前会得到处理。在程序看来，上述注释等于以下写法</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">is a newline</span><br><span class="line"></span><br><span class="line"><span class="comment">// look inside c:\users</span></span><br><span class="line"><span class="comment">// 因为程序认为，\users 不是一个合法的转义字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在某些场合下这种写法似乎也能实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>\u005B\u005D a;			<span class="comment">// int[] a; 一个数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-6-2-字符本质与编码表"><a href="#2-6-2-字符本质与编码表" class="headerlink" title="2.6.2 字符本质与编码表"></a>2.6.2 字符本质与编码表</h2><ul>
<li><p>字符类型的本质，是把字符对应的码值编程二进制，存储。显示时将二进制代码转化为码值，找到对应的字符。</p>
</li>
<li><p>字符与码值的对应关系是字符编码表规定的。</p>
<blockquote>
<p>ASCII 编码表，占用 1 byte，共有 128 个字符。<br>Unicode 编码表，占用 2 byte，字母汉字都占用 2 byte，这样可能浪费空间。0 - 127 的字符与 ASCII 相同，所以兼容 ASCII。<br>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1 byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode 实现方式。<br>GBK 编码表，可以表示汉字，字母占用 1 byte，汉字占用 2 byte。<br>GB2312 编码表，可以表示汉字（GB2312 &lt; GBK）<br>BIG5 编码表，可以存放繁体中文（香港，台湾）</p>
</blockquote>
</li>
<li><p>UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。包含从 U+0000 到 U+FFFF 的经典 Unicode 代码（16位，1 个代码单元），以及 U+10000 到 U+10FFFF 的辅助字符（32位，2 个代码单元）</p>
</li>
<li><p>在 Java 中，char 类型描述的是 UTF-16 编码中的 1 个代码单元。字符串中的一个辅助字符（如 🎶）可能占用 2 个代码单元。这个场合，使用 char 可能会导致错误</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;🎶An🎶&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(<span class="number">1</span>);			<span class="comment">// &lt;———— 这个场合，c 是 🎶 符号的第二个代码单元而非 &#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong><em>因此，一般不建议在程序中使用 char 类型</em></strong></p>
</li>
</ul>
<h1 id="2-7-布尔类型"><a href="#2-7-布尔类型" class="headerlink" title="2.7 布尔类型"></a>2.7 布尔类型</h1><blockquote>
<p><code>boolean</code> 只允许取值<code>ture</code> 或 <code>false</code> ，没有 <code>null</code>。适用于逻辑运算，通常用于程序流程控制<br><code>if</code> <code>while</code> <code>do-while</code> <code>for</code></p>
</blockquote>
<p><strong>使用细节：</strong></p>
<ol>
<li>不可以用 <code>0</code> 或 <code>非0</code> 的整数替代<code>false</code> 或 <code>ture</code> 。这点和 C语言 不同。</li>
<li>不能让布尔类型转换为其他类型。</li>
</ol>
<h1 id="2-8-基本数据类型转换"><a href="#2-8-基本数据类型转换" class="headerlink" title="2.8 基本数据类型转换"></a>2.8 基本数据类型转换</h1><h2 id="2-8-1-自动类型转换"><a href="#2-8-1-自动类型转换" class="headerlink" title="2.8.1 自动类型转换"></a>2.8.1 自动类型转换</h2><blockquote>
<p>自动类型转换：Java 在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。<br><code>char</code> -&gt; <code>int</code> -&gt; <code>long</code> -&gt; <code>float</code> -&gt; <code>double</code><br><code>byte</code> -&gt; <code>short </code>-&gt; <code>int</code> -&gt; <code>float</code> -&gt; <code>double</code><br><strong>注意：</strong><code>**char**</code>** 、**<code>**byte**</code><strong>、</strong><code>**short**</code>** 之间不可转换**</p>
</blockquote>
<p><strong>细节：</strong></p>
<ol>
<li>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。</li>
<li>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。反之进行自动类型转换。</li>
<li><code>byte</code> <code>short</code> <code>char</code> 三者不会相互自动转换，但可以计算。计算时首先转化为 <code>int</code>。</li>
<li><code>boolean</code> 类型不参与自动转换</li>
<li>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。</li>
</ol>
<h2 id="2-8-2-强制转换"><a href="#2-8-2-强制转换" class="headerlink" title="2.8.2 强制转换"></a>2.8.2 强制转换</h2><blockquote>
<p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符 ( ) ，但可能造成<strong>精度降低或溢出</strong>，要格外注意。</p>
</blockquote>
<p><strong>细节:</strong></p>
<ol>
<li><p>当进行数据从大到小转换时，用强制转换。</p>
</li>
<li><p>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code> 提升优先级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">3</span> * <span class="number">2.5</span> + <span class="number">1.1</span> * <span class="number">6</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10</span> * <span class="number">0.1</span> * <span class="number">1</span>; <span class="comment">// int 只会转换 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>char</code> 可以保留 <code>int</code> 的常量值，但不能保存其变量值。此时需要强制类型转换。</p>
</li>
<li><p><code>byte</code> <code>short</code> <code>char</code> 在进行运算时，当作<code>int</code> 处理。</p>
</li>
</ol>
<h2 id="2-8-3-基本数据类型和String的转换"><a href="#2-8-3-基本数据类型和String的转换" class="headerlink" title="2.8.3 基本数据类型和String的转换"></a>2.8.3 基本数据类型和<code>String</code>的转换</h2><ul>
<li><p>**基本类型转 **<code>**String**</code>**：基本数据类型加上 **<code>**&quot; &quot;**</code><strong>。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> n1 + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>**String**</code><strong>转基本数据类型：通过基本数据类型的包装类调用</strong><code>**parseXX**</code>** 方法。**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Interger.parseInt(s);</span><br></pre></td></tr></table></figure>
<p>特别的，把 <code>String</code> 转换为 <code>char</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);		<span class="comment">// 得到 s 字符串中的第一个字符。</span></span><br></pre></td></tr></table></figure>
<p><strong>细节:</strong></p>
</li>
</ul>
<ol>
<li>将<code>String</code> 转成基本数据类型时，要保证其能转换为有效数据。即不能把 “Hello” 转换成 <code>int</code>。</li>
<li>如果格式不正确，会抛出异常，程序会中止。</li>
</ol>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 运算符</title>
    <url>/2022/09/11/JavaSE/3.%20%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。</p>
</blockquote>
<h1 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h1><blockquote>
<p>算术运算符是对数值类型的变量进行运算的运算符，在 Java 程序中使用得非常多。其运算结果是一个数值量。</p>
</blockquote>
<ul>
<li><p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>：加、减、乘、除</p>
<blockquote>
<p><code>5 / 2 = 2;</code> 因为是 <code>int</code> 。 同理 <code>5.0 / 2 = 2.5</code></p>
</blockquote>
</li>
<li><p><code>%</code>：取模符，就是取余数</p>
<blockquote>
<p><code>5 % 2 = 1</code> 5 除以 2 的 余数为 1</p>
</blockquote>
</li>
<li><p><code>++</code>：自增</p>
<blockquote>
<p><code>++i</code>: 先自增后运算 |  <code>i++</code>: 先运算后自增</p>
</blockquote>
</li>
<li><p><code>--</code>：自减</p>
<blockquote>
<p>与 <code>++</code> 同理</p>
</blockquote>
</li>
<li><p><code>+</code>：字符串相加</p>
</li>
</ul>
<h1 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h1><blockquote>
<p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>ture</code> 要么是 <code>false</code>。其关系表达式经常用在 <code>if 结构</code>的条件中或循环结构的条件中。</p>
</blockquote>
<ul>
<li><code>==</code>：相等于</li>
<li><code>!=</code> : 不等于</li>
<li><code>&lt;``&gt;</code>: 小于、大于</li>
<li><code>&lt;=</code> <code>&gt;=</code> : 小于等于、大于等于</li>
<li><code>instanceof</code> : 检查是否是类的对象</li>
</ul>
<p><strong>细节：</strong></p>
<ol>
<li><strong>关系运算符的结果都是 <code>boolean</code> 类型，即要么为 <code>true</code> 要么为 <code>false</code>。</strong></li>
<li><strong>关系运算符的表达式被称为_关系表达式_</strong></li>
<li><strong>比较运算符<code>==</code>要和赋值运算符<code>=</code>区分。(新手易混)</strong></li>
<li><strong>Java 允许将 <code>==</code>、<code>!=</code>两种运算用于任何数据类型</strong></li>
<li><strong>字符串的比较通常用 <code>equals()</code> 方法来比较。</strong></li>
</ol>
<h1 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3 逻辑运算符"></a>3.3 逻辑运算符</h1><blockquote>
<p>用于连接多个条件（多个关系表达式），最终的结果也是一个 <code>boolean</code> 值。</p>
</blockquote>
<ul>
<li><p><code>&amp;&amp;</code>: <strong>短路与</strong>。前后皆为<code>true</code>，则结果为<code>true</code>，否则为<code>false</code>。</p>
</li>
<li><p><code>&amp;</code>：<strong>逻辑与</strong>。前后皆为<code>true</code>，则结果为<code>true</code>，否则为<code>false</code>。</p>
<blockquote>
<p><strong>区别：短路与当前者为<code>false</code>时就暂停不会去判断后者，而逻辑与会完成整个判断。在实际开发中多用短路与。因为效率更高。</strong></p>
</blockquote>
</li>
<li><p><code>||</code>：<strong>短路或</strong>。前后有一个为<code>true</code>，则为<code>true</code>，否则为<code>false</code>。</p>
</li>
<li><p><code>|</code> ：<strong>逻辑或</strong>。前后有一个为<code>true</code>，则为<code>true</code>，否则为<code>false</code>。</p>
<blockquote>
<p><strong>区别：和短语与相同，若前者为true，就不会去判断后者的结果。</strong></p>
</blockquote>
</li>
<li><p><code>！</code>：<strong>取反</strong>。<code>true</code>变成<code>false</code>，<code>false</code>变为<code>true</code>。</p>
</li>
<li><p><code>^</code>：<strong>逻辑异或</strong>。前后不同时为<code>true</code>，否则为<code>false</code>。</p>
</li>
</ul>
<h1 id="3-4-赋值运算符"><a href="#3-4-赋值运算符" class="headerlink" title="3.4 赋值运算符"></a>3.4 赋值运算符</h1><blockquote>
<p>将某个运算后的值，赋给指定变量</p>
</blockquote>
<ul>
<li>基本赋值运算符：<code>=</code></li>
<li>符合赋值运算符：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code><blockquote>
<p>a +&#x3D; b  &#x3D;&gt; a &#x3D; a + b;  &#x2F;&#x2F; 二者相等</p>
</blockquote>
</li>
</ul>
<p><strong>细节:</strong></p>
<ol>
<li><strong>运算顺序从右往左。</strong></li>
<li><strong>运算符左边只能是变量，右边可以是变量、表达式、常量值。</strong></li>
<li><strong>复合赋值运算符会进行类型转换。</strong></li>
</ol>
<h1 id="3-5-三元运算符"><a href="#3-5-三元运算符" class="headerlink" title="3.5 三元运算符"></a>3.5 三元运算符</h1><blockquote>
<p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p>
</blockquote>
<p>运算规则：如果条件表达式的结果为<code>true</code>， 则执行表达式1，否则执行表达式2。<br><strong>细节：</strong></p>
<ol>
<li><strong>表达式1和表达式2要为可以赋给接受变量的类型（可以自己转换）</strong></li>
<li>**三元运算符可以转换为<code>if-else</code></li>
<li><strong>三元运算符是一个整体。</strong></li>
</ol>
<h1 id="3-6-运算符优先级"><a href="#3-6-运算符优先级" class="headerlink" title="3.6 运算符优先级"></a>3.6 运算符优先级</h1><h1 id="3-7-标识符"><a href="#3-7-标识符" class="headerlink" title="3.7 标识符"></a>3.7 标识符</h1><blockquote>
<p>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符凡是自己可以起名字的地方都叫标识符</p>
</blockquote>
<h2 id="3-7-1-命名规则"><a href="#3-7-1-命名规则" class="headerlink" title="3.7.1 命名规则"></a>3.7.1 命名规则</h2><ol>
<li>标识符由字母、数字、_或$组成。</li>
<li>数字不能开头。</li>
<li>不可以使用关键字和保留字。</li>
<li>不能包含空格。</li>
<li>可以使用任何的Unicode字符作为标识符。但不推荐。</li>
</ol>
<h2 id="3-7-2-命名规范"><a href="#3-7-2-命名规范" class="headerlink" title="3.7.2 命名规范"></a>3.7.2 命名规范</h2><ol>
<li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc</li>
<li>类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz</li>
<li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li>
<li>更详细的规则查看 <a href="https://developer.aliyun.com/article/709470">Java 编码规范</a></li>
</ol>
<h1 id="3-8-输入与输出"><a href="#3-8-输入与输出" class="headerlink" title="3.8 输入与输出"></a>3.8 输入与输出</h1><blockquote>
<p>为满足读取用户输入、输出的需求，Java 提供了几个基本类</p>
</blockquote>
<h2 id="3-8-1-Scanner-类"><a href="#3-8-1-Scanner-类" class="headerlink" title="3.8.1 Scanner 类"></a>3.8.1 Scanner 类</h2><blockquote>
<p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。<code>Input.java</code> ，需要一个 扫描器（对象），就是 <code>Scanner</code>。<code>Scanner</code> 属于 <code>java.util</code> 包。其包含许多方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 1. 导入包名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Input</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 2. 创建对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一行字符：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next(); <span class="comment">// 3. 接收用户输入</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造方法：</strong></p>
<ul>
<li><code>new Scanner(System.in)</code>：该方法接收一个参数（输入源）。其中 <code>System.in</code> 代表标准输入流。默认情况指键盘。</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li><code>String next()</code>：读取下一个输入对象<code>Scanner</code> 对象用空白（空格、水平制表符或回车换行符）作为输入的分隔元素</li>
<li><code>Double nextDouble()</code>：读取下一个 <code>double</code></li>
<li><code>Int nextInt()</code>：读取下一个<code> int</code></li>
<li><code>String nextLine()</code>：读入当前行的所有输入，直到行尾</li>
<li><code>boolean hasNext()</code>：输入中是否还有其他单词</li>
<li><code>boolean hasNextInt()</code>、<code>boolean hasNextDouble()</code></li>
</ul>
<h2 id="3-8-2-格式化输出"><a href="#3-8-2-格式化输出" class="headerlink" title="3.8.2 格式化输出"></a>3.8.2 格式化输出</h2><blockquote>
<p><code>System.out</code> 标准输出流。调用该流方法以输出内容至控制台窗口</p>
</blockquote>
<ul>
<li><code>println(String s)</code>：输出字符，结束后换行</li>
<li><code>print(String s)</code>：输出字符，结束后不换行</li>
<li><code>println(int n)</code>、<code>println(char c)</code>、<code>println(Object obj)</code>……</li>
<li><code>printf(String format, Object ... args)</code>：格式化输出<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%s测试%d&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="number">1</span>);	<span class="comment">// &lt;—— abcd测试1</span></span><br></pre></td></tr></table></figure>
以 % 开头的 格式说明符 都用相应参数替换。格式说明符尾部的转换符表示要格式化的数值类型</li>
</ul>
<h1 id="3-9-进制"><a href="#3-9-进制" class="headerlink" title="3.9 进制"></a>3.9 进制</h1><ul>
<li><strong>二进制</strong>：数字有 0 - 1，满 2 进 1，以 <code>0b</code> 或 <code>0B </code>开头</li>
<li><strong>十进制</strong></li>
<li><strong>八进制</strong>：0 - 7，满 8 进 1，以 <code>0 </code>开头表示</li>
<li><strong>十六进制</strong>：0 - 9 及 A - F，满 16 进 1，以<code>0x </code>或 <code>0X </code>开头。此处的 A - F 不分大小写。</li>
</ul>
<h2 id="3-9-1-进制的转换"><a href="#3-9-1-进制的转换" class="headerlink" title="3.9.1 进制的转换"></a>3.9.1 进制的转换</h2><ul>
<li><strong>其他进制 转 十进制</strong>：略</li>
<li><strong>十进制 转 其他进制</strong>：将该数不断除以对象进制数，直到商为0为止，将每步得到的余数倒过来。</li>
<li><strong>二进制 与 八进制 或 十六进制 互相转换</strong>：二进制 从低位开始，<strong>每 3 位一组</strong>，转成对应的 八进制 即可。反之同理。十六进制亦同理（<strong>每 4 位一组</strong>）。</li>
</ul>
<h2 id="3-9-2-原码、反码、补码"><a href="#3-9-2-原码、反码、补码" class="headerlink" title="3.9.2 原码、反码、补码"></a>3.9.2 原码、反码、补码</h2><ol>
<li>二进制的最高位是符号位：0表示正数，1表示负数。</li>
<li><strong>正数的原码、反码、补码都一样。</strong></li>
<li>负数的反码 &#x3D; 原码符号位不变，其他位取反（0 变 1，1 变 0）</li>
<li><strong>负数的补码 &#x3D; 反码 + 1。也就是说，负数的反码 &#x3D; 补码 - 1</strong></li>
<li>0 的反码、补码都是 0。</li>
<li>Java 没有无符号数。换言之，Java 的数都是有符号的。</li>
<li><strong>计算机运算时，都是以补码的方式来运算的。</strong></li>
<li><strong>当我们看运算结果时，要看其原码。</strong></li>
</ol>
<h1 id="3-10-位运算符"><a href="#3-10-位运算符" class="headerlink" title="3.10 位运算符"></a>3.10 位运算符</h1><ul>
<li><code>&amp;</code> <strong>按位与</strong>：两位都为 1，结果为 1，否则为 0</li>
<li><code>|</code>按位或**：两位有一个为 1，结果为 1，否则为 0</li>
<li><code>^</code> <strong>按位异或</strong>：两位不同，结果为 1，否则为 0</li>
<li><code>~</code> <strong>按位取反</strong>：把 0 变 1，1 变 0</li>
<li><code>&gt;&gt;</code> <strong>算术右移</strong>：低位溢出，符号位不变，用符号位补溢出的高位</li>
<li><code>&lt;&lt;</code> <strong>算数左移</strong>：符号位不变，低位补 0</li>
<li><code>&gt;&gt;&gt;</code> <strong>逻辑右移（无符号右移）</strong>：低位溢出，高位补 0</li>
</ul>
<p><strong>细节:</strong></p>
<ol>
<li>位运算符只对整型、字符类型有效</li>
<li>移位运算中，左侧操作 int 的场合，右侧操作数以 32 取模；long 的场合，右侧操作数以 64 取模。</li>
</ol>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 程序控制结构</title>
    <url>/2022/09/11/JavaSE/4.%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>程序运行的流程控制决定程序是如何执行的，是我们必须掌握的。主要分为：顺序控制、分支控制、循环控制。</p>
</blockquote>
<h1 id="4-1-顺序控制"><a href="#4-1-顺序控制" class="headerlink" title="4.1 顺序控制"></a>4.1 顺序控制</h1><blockquote>
<p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）比如：Java 定义变量时采用合法的前向引用。</p>
</blockquote>
<p>语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。</p>
<ul>
<li><strong>单语句</strong>：通常意义的一条语句。语句间以分号 ; 分隔。</li>
<li><strong>复合语句</strong>：一对大括号括起来的语句组。也称为 “块”<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 单语句</span></span><br><span class="line">&#123;</span><br><span class="line">	语句<span class="number">1</span>;</span><br><span class="line">	语句<span class="number">2</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 语句块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 块中可以有多条语句。块后没有分号;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="4-2-分支控制-if-else"><a href="#4-2-分支控制-if-else" class="headerlink" title="4.2 分支控制 if-else"></a>4.2 分支控制 <code>if-else</code></h1><blockquote>
<p>让程序有选择的执行。主要分为：单分支控制、双分支控制</p>
</blockquote>
<h2 id="4-2-1-单分支控制"><a href="#4-2-1-单分支控制" class="headerlink" title="4.2.1 单分支控制"></a>4.2.1 单分支控制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) 语句;</span><br><span class="line"><span class="comment">// 多个语句则用</span></span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当条件表达式整体为<code>true</code>时则会执行语句或者代码块。</strong></p>
<h2 id="4-2-2-双分支控制"><a href="#4-2-2-双分支控制" class="headerlink" title="4.2.2 双分支控制"></a>4.2.2 双分支控制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line"> 执行代码块<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> 执行代码块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当条件表达式为 <code>ture</code>，就会执行 <code>&#123;执行代码块1;&#125;</code>；如果为 <code>false</code> 则执行 <code>&#123;执行代码块2;&#125;</code>。</strong></p>
<h2 id="4-2-3-多分支控制"><a href="#4-2-3-多分支控制" class="headerlink" title="4.2.3 多分支控制"></a>4.2.3 多分支控制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">2</span>) &#123;</span><br><span class="line"> 执行代码块<span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式<span class="number">3</span>) &#123;</span><br><span class="line"> 执行代码块<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> 执行代码块n；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别地：多分支可以没有 <code>else</code>。此时如果条件都不成立，则无执行入口</strong></p>
<h2 id="4-2-4-嵌套分支"><a href="#4-2-4-嵌套分支" class="headerlink" title="4.2.4 嵌套分支"></a>4.2.4 嵌套分支</h2><blockquote>
<p>在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。</p>
</blockquote>
<p><strong>Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if 语句</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) n++;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">1</span>) n++;</span><br><span class="line"><span class="keyword">else</span> n--;			<span class="comment">//属于上面这个 if 语句</span></span><br><span class="line"><span class="comment">//这个场合，这个 else 语句属于上面的 if (n &gt; 1) 这个语句</span></span><br></pre></td></tr></table></figure>
<p><strong>要想改变那个匹配关系，要使用 <code>&#123; &#125;</code> 改变语句结构：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    n++;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>) n++;  </span><br><span class="line">&#125; <span class="keyword">else</span> n--;</span><br></pre></td></tr></table></figure>
<p><strong>规范</strong>：嵌套尽量不超过 3 层（可读性不好）</p>
<h1 id="4-3-分支控制-switch"><a href="#4-3-分支控制-switch" class="headerlink" title="4.3 分支控制 switch"></a>4.3 分支控制 <code>switch</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">		语句块<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;			<span class="comment">//break 语句可选</span></span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">		语句块<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;			<span class="comment">//break 语句可选</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:			<span class="comment">//default 语句可选</span></span><br><span class="line">		<span class="keyword">default</span>语句块;</span><br><span class="line">		<span class="keyword">break</span>;			<span class="comment">//break 语句可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>switch</code> 关键字，表示 <code>switch</code> 分支。</li>
<li>表达式 对应一个值。<strong>该值必须是 <code>int</code> 或 <code>char</code>（char 可以转化为 int）。</strong>是 <code>byte</code> 或 <code>short</code> 的场合，要提升为 <code>int</code>。不允许 <code>long</code>、<code>double</code> 或 <code>float</code></li>
<li><code>case 常量1;</code> <strong>表示</strong>：当 <code>表达式</code> 的值等于 <code>常量1</code> ，则执行 <code>语句块1</code>。</li>
<li><code>break;</code> <strong>表示退出 switch 分支。</strong></li>
<li>当 <code>表达式</code> 的值匹配 <code>常量1</code> ，则执行 <code>语句块1</code>，如果不匹配，则继续匹配 <code>常量2 </code>，以此类推。</li>
<li>如果全都不匹配，则执行 <code>default</code>。</li>
<li>如果不写 <code>break;</code> ，则会发生<strong>穿透</strong>，即不进行判断而继续执行下一语句块。</li>
</ol>
<p><strong>细节：</strong></p>
<ol>
<li><code>表达式;</code> 数据类型，应和<code> case</code> 后的 <code>常量</code> 类型一致，或者是可以自动转换成可以比较的类型。如：输入的是 <code>char</code> 而 <code>常量</code> 是 <code>int</code></li>
<li><code>switch</code> 中 表达式 的返回值必须是：<code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>enum</code> <code>String</code></li>
<li><code>case</code> 语句中的值必须是 <code>常量</code> 或 <code>常量表达式</code>，不能是 <code>变量</code>。</li>
<li><code>default</code> 是可选的。没有就不执行。</li>
<li><code>break;</code> 用来跳出 <code>switch</code> 分支。如果不写，会持续执行语句，直到分支结束或遇到下一个 <code>break;</code></li>
</ol>
<h2 id="4-3-1-与-if-else的取舍"><a href="#4-3-1-与-if-else的取舍" class="headerlink" title="4.3.1 与 if-else的取舍"></a>4.3.1 与 <code>if-else</code>的取舍</h2><ul>
<li>如果判断的具体数值不多，推荐使用 switch。</li>
<li>对区间判断的场合，对结果为 boolean 类型的判断，使用 if-else。</li>
</ul>
<h1 id="4-4-循环控制-for"><a href="#4-4-循环控制-for" class="headerlink" title="4.4 循环控制 for"></a>4.4 循环控制 <code>for</code></h1><blockquote>
<p>让代码可以循环执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量初始化;循环条件;循环变量迭代)&#123;</span><br><span class="line">	循环操作（代码块）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for</code> 关键字，表示循环控制</li>
<li>四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4. 循环变量迭代</li>
<li>所有循环开始前仅一次进行初始化。直到循环条件变为 <code>false</code> 前，执行循环操作。每轮循环结束后，进行循环变量迭代。</li>
<li>循环操作可以有多条语句</li>
<li>如果循环操作只有一条语句，可以省略 <code>&#123;&#125;</code>，但建议不省略</li>
</ul>
<p><strong>细节：</strong></p>
<ol>
<li>循环条件是返回一个 <code>boolean</code> 值（<code>ture</code> 或 <code>false</code>）的公式。循环条件可以为空。这个场合，默认为真（<code>true</code>）</li>
<li><code>for(;循环条件;)&#123; &#125;</code>其中的初始化和变量迭代可以写在别处，但 <code>;</code>不能省略。如果不写在别处，那个 循环变量初始化 中声明的变量只能在该<code>for</code> 循环中使用。</li>
<li>控制台用 <code>ctrl + c</code> 强制结束一个流程</li>
<li>循环初始值可以有多条初始化语句，但要求类型一样，并用 <code>,</code>隔开。变量迭代也可以有多条代码，用<code>,</code> 隔开。</li>
</ol>
<h2 id="4-4-1-for-each-泛型for循环"><a href="#4-4-1-for-each-泛型for循环" class="headerlink" title="4.4.1 for each 泛型for循环"></a>4.4.1 <code>for each</code> 泛型<code>for</code>循环</h2><blockquote>
<p>泛型 for 循环（增强 for 循环）能用来依次处理数组（或其他元素集合）中的每个元素，而不必考虑下标值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;						<span class="comment">//其中 nums 是一个一维 int 数组</span></span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述写法（增强 for 写法）类似于以下写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">	System.out.println(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泛型 for 循环适用于数组或一个实现了 Iterable 接口的对象。泛型 for 循环的本质是一个 Iterator（迭代器）</p>
<h1 id="4-5-循环控制-while"><a href="#4-5-循环控制-while" class="headerlink" title="4.5 循环控制 while"></a>4.5 循环控制 <code>while</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line"> 循环体(代码块);</span><br><span class="line"> 循环变量迭代;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>while</code> 也有四要素，只是位置和 <code>for</code> 不同**<br><strong>细节：</strong></p>
<ol>
<li>循环条件是返回一个 <code>boolean</code> 值（<code>ture</code> 或 <code>false</code>）的公式。<code>while</code> 循环中，循环条件不能为空。</li>
<li><code>while</code> 循环是先判断再执行语句。</li>
</ol>
<h1 id="4-6-循环控制-do-while"><a href="#4-6-循环控制-do-while" class="headerlink" title="4.6 循环控制 do...while"></a>4.6 循环控制 <code>do...while</code></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">循环体;</span><br><span class="line">循环变量迭代;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>do while </code>是关键字</li>
<li>也有<strong>四要素</strong>，<strong>位置不同</strong></li>
<li>先执行，再判断。也就是说，一定会至少执行一次</li>
<li>**最后有一个<code>;</code></li>
<li><code>while</code> 与 <code>do..while</code> 区别：”要账”</li>
</ol>
<p><strong>细节:</strong></p>
<ol>
<li>循环条件是返回一个 <code>boolean</code> 值（<code>ture</code> 或 <code>false</code>）的公式。</li>
<li><code>do..while</code> 循环是先执行再判断的语句。因此至少执行一次。</li>
</ol>
<h1 id="4-7-多重循环控制"><a href="#4-7-多重循环控制" class="headerlink" title="4.7 多重循环控制"></a>4.7 多重循环控制</h1><blockquote>
<p>将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。<br>嵌套循环 是把 内层循环 当成 外层循环 的 循环体。只有内层 false 时才可能结束当层循环。<br>若内层执行 n 次，外层 m 次，则合计会循环 n*m 次</p>
</blockquote>
<h1 id="4-8-跳转控制语句"><a href="#4-8-跳转控制语句" class="headerlink" title="4.8 跳转控制语句"></a>4.8 跳转控制语句</h1><blockquote>
<p>跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向</p>
</blockquote>
<h2 id="4-8-1-标签"><a href="#4-8-1-标签" class="headerlink" title="4.8.1 标签"></a>4.8.1 标签</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a:&#123;</span><br><span class="line">b:	&#123;</span><br><span class="line">c:		&#123;</span><br><span class="line">   ...</span><br><span class="line">		 berak b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>a:</code> <code>b:</code> <code>c:</code> 是标签，名字由程序员指定</li>
<li>break 后指定哪个标签就退出到哪里</li>
<li><strong>实际开发中，尽量不要使用标签</strong></li>
</ol>
<h2 id="4-8-2-break"><a href="#4-8-2-break" class="headerlink" title="4.8.2 break"></a>4.8.2 break</h2><blockquote>
<p>用于中止一个语句块的执行</p>
</blockquote>
<p><strong>break 可以被用在三种场合中</strong></p>
<ul>
<li><code>switch</code> 语句中，以跳出判断（结束穿透）</li>
<li><code>for</code>、<code>while</code>、<code>do…while</code> 循环语句中，以跳出循环</li>
<li>语句块中，以跳过本块中所有剩余语句<code>break</code> 语句出现在多层嵌套的语句块中时，可以通过 标签 指明要终止的时哪一层语句块。</li>
</ul>
<h2 id="4-8-3-continue"><a href="#4-8-3-continue" class="headerlink" title="4.8.3 continue"></a>4.8.3 continue</h2><blockquote>
<p>在循环中出现。用于结束本次循环，继续下一次循环</p>
</blockquote>
<p>进行下次循环前，仍会判断循环条件是否满足<br>在多层嵌套循环中，可以通过标签指出跳出哪次循环（同 <code>break</code>）</p>
<h2 id="4-8-4-return"><a href="#4-8-4-return" class="headerlink" title="4.8.4 return"></a>4.8.4 return</h2><p>方法有返回值的场合，将返回值写在 <code>return</code> 后：<code>return 值;</code><br>如果写在 主方法 则跳出程序</p>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 数组 排序和查找</title>
    <url>/2022/09/11/JavaSE/5.%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<blockquote>
<p><strong>数组</strong>：可以存放多个同一类型的数据。数组也是一种数据，是引用类型。<br><strong>即</strong>：数组就是一组数据。</p>
</blockquote>
<h1 id="5-1-一维数组"><a href="#5-1-一维数组" class="headerlink" title="5.1 一维数组"></a>5.1 一维数组</h1><h2 id="5-1-1-基本介绍"><a href="#5-1-1-基本介绍" class="headerlink" title="5.1.1 基本介绍"></a>5.1.1 基本介绍</h2><blockquote>
<ol>
<li>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。</li>
<li>数组中的元素可以是任何数据类型。包括基本类型和引用类型。</li>
<li><strong>数组的下标从 0 开始。且必须在指定范围内使用，否则报错。</strong></li>
<li>数组属于 引用类型，数组型数据是 对象（Object）</li>
<li>数组创建后，如果没有赋值，有默认值：int（0），short（0），byte（0），long（0L），float（0.0F），double（0.0），char（\u0000），boolean（false），String（null），Object（null）</li>
</ol>
</blockquote>
<p><strong>数组的构造方法 :</strong><br>使用数组的步骤：1. 声明数组并开辟空间  2. 给数组中各个元素赋值 3. 使用数组</p>
<ul>
<li><p>构造方式1：动态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];				<span class="comment">// 创建了数组 name，存放5个int</span></span><br><span class="line"><span class="type">int</span> ints2[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];				<span class="comment">// 这种写法也行</span></span><br><span class="line">ints[<span class="number">2</span>] = <span class="number">15</span>;							<span class="comment">// 访问数组第3个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方式2：动态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] chars;							<span class="comment">// 先声明数组 name，此时数组是 null</span></span><br><span class="line">chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];					<span class="comment">// 分配内存空间，可以存放数据了</span></span><br><span class="line">chars[<span class="number">1</span>] = <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方式3：静态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span>[] bools = &#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;阿伟，你又在打电动噢&quot;</span>, <span class="string">&quot;烦啦&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>确切知道数组每个元素的场合可以使用这个构造方法。</p>
</blockquote>
</li>
</ul>
<p><strong>数组的使用方法：</strong></p>
<ul>
<li>访问数组元素：<code>数组名[元素下标]</code></li>
</ul>
<p>其中，元素下标从0开始编号。如：访问strs数组的第一个元素为：<code>strs[0]</code>.</p>
<ul>
<li>数组长度：<code>数组名.length</code></li>
</ul>
<p>是一个int值。不能通过试图改变该值来改变数组容量。</p>
<h2 id="5-1-2-数组赋值机制"><a href="#5-1-2-数组赋值机制" class="headerlink" title="5.1.2 数组赋值机制"></a>5.1.2 数组赋值机制</h2><ol>
<li>基本数据类型赋值，赋值方式是值拷贝。这个值就是具体的数据，且互不影响</li>
<li>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] array2 = array1;</span><br><span class="line">array2[<span class="number">0</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
上述情况下，array1[0] 也会变成 100。因为数组在 JVM 的 栈 里是一个地址，指向 堆 里的一个空间。这两个数组在上述情况下指向同一空间。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[array1.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array1.length;i++) &#123;</span><br><span class="line">    array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述方式拷贝后，两数组相互独立。</li>
</ol>
<h2 id="5-1-3-数组的扩容"><a href="#5-1-3-数组的扩容" class="headerlink" title="5.1.3 数组的扩容"></a>5.1.3 数组的扩容</h2><p>当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。<br>以下是一个扩容方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code5_1_3</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">inP</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;		<span class="comment">// 这是原数组</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> <span class="number">0</span>;				<span class="comment">// 这个变量记录输入的新元素的值</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> arr1.length;	<span class="comment">// 这个变量是新数组的长度</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">yN</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;				<span class="comment">// 记录询问继续与否时用户的输入字符</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">       	<span class="comment">/* 创建多一位的新数组，把新元素赋给新数组的最后一位 */</span></span><br><span class="line">				System.out.println(<span class="string">&quot;请输入添加数字：&quot;</span>);</span><br><span class="line">				add = inP.nextInt();</span><br><span class="line">				<span class="type">int</span>[] tem = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length + <span class="number">1</span>];</span><br><span class="line">				tem[count] = add;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">/* 把旧数组的值全部赋给新数组 */</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">					tem[i] = arr1[i];</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">/* 把新数组保存下来，输出现在的数组 */</span></span><br><span class="line">				arr1 = tem;</span><br><span class="line">				count++;</span><br><span class="line">				System.out.println(<span class="string">&quot;\n\n当前数组为：&quot;</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">					System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">/* 询问是否继续添加，输入n跳出，否则循环 */</span></span><br><span class="line">				System.out.println(<span class="string">&quot;\n\n是否继续添加？（Y/N）&quot;</span>);</span><br><span class="line">				yN = inP.next().charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		&#125;<span class="keyword">while</span>(yN != <span class="string">&#x27;N&#x27;</span> &amp;&amp; yN != <span class="string">&#x27;n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-2-二维数组"><a href="#5-2-二维数组" class="headerlink" title="5.2 二维数组"></a>5.2 二维数组</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] ints;					<span class="comment">// 声明一个二维数组</span></span><br><span class="line"><span class="type">int</span>[] ints2[];					<span class="comment">// 也能这样声明</span></span><br><span class="line"><span class="type">int</span> ints3[][];					<span class="comment">// 这样也行</span></span><br><span class="line"><span class="type">int</span>[] x,y[];					<span class="comment">// 声明了两个数组，一个是 int[] x 一个是 int[][] y</span></span><br><span class="line">								<span class="comment">// 把 int[] 视作一个类型，就能很好地理解这个写法</span></span><br></pre></td></tr></table></figure>
<p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。<br>数组是一个对象，所以二维数组的元素存放的是一维数组的地址。<br><strong>二维数组的构造方法：</strong></p>
<ul>
<li><p><strong>构造方法1：动态初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] many_ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>]	<span class="comment">// 创建 有3个 包含4个元素的一维数组 的二维数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造方法2：动态初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>[][] many_doubles;			<span class="comment">// 先声明变量</span></span><br><span class="line">many_doubles = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">3</span>][<span class="number">4</span>];	<span class="comment">// 再开辟空间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造方法3：动态初始化-列数不确定</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[][] many_chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>][];	<span class="comment">// 创建一个三行列数不确定的二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    many_chars[i] = <span class="keyword">new</span> <span class="title class_">char</span>[i + <span class="number">1</span>];	<span class="comment">// 此时，每个数组空间依次增大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>构造方法4：静态初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] many_many = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">10</span>, <span class="number">2</span>&#125;, &#123;<span class="number">95</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>二维数组的使用方法：</strong></p>
</li>
<li><p><code>ints.length</code>: 该二维数组的长度</p>
</li>
<li><p><code>ints[0]</code>: 该二维数组的第一个子数组</p>
</li>
<li><p><code>ints[0].length</code>: 该二维数组第一个子数组的长度</p>
</li>
<li><p><code>int[1][0]</code>: 该二维数组的第二个子数组的第一个元素的值</p>
</li>
</ul>
<h1 id="5-3-查找算法"><a href="#5-3-查找算法" class="headerlink" title="5.3 查找算法"></a>5.3 查找算法</h1><p><strong>在 Java 中，常用的查找有 4 种：</strong></p>
<ul>
<li>顺序查找（遍历）</li>
<li>二分查找</li>
<li>插值查找</li>
<li>斐波那契查找</li>
</ul>
<h2 id="5-3-1-顺序查找"><a href="#5-3-1-顺序查找" class="headerlink" title="5.3.1 顺序查找"></a>5.3.1 顺序查找</h2><blockquote>
<p>逐一比对，直到发现目标值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">seqSearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-2-二分查找"><a href="#5-3-2-二分查找" class="headerlink" title="5.3.2 二分查找"></a>5.3.2 二分查找</h2><blockquote>
<p>二分查找要求数组必须是有序数组。<br>每次取出那个中位数。目标值大于中位数的场合，则在较小一侧的范围内继续二分查找。否则在那个较大一侧查找。<br>递归方式二分查找：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(array, target, <span class="number">0</span>, array.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> -l - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target == array[p]) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[p]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(array, target, p + <span class="number">1</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> binarySearch(array, target, l, p - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非递归方式二分查找：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch2</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="keyword">while</span> (r &gt; l) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> (r + l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == array[p]) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[p]) l = p + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = p - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -l - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-3-插值查找"><a href="#5-3-3-插值查找" class="headerlink" title="5.3.3 插值查找"></a>5.3.3 插值查找</h2><blockquote>
<p>插值查找类似于二分查找，但其不是取出中位数，而是从自适应的位置取出一个元素<br>那个自适应的取出位置 mid &#x3D; low + (target - arr[low]) × (high - low) &#x2F; (arr[high] - arr[low])<br>如若那个目标值更靠近某一端，这个自适应的取出位置也会更接近那一端</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertSearch</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target &gt; array[array.length - <span class="number">1</span>]) <span class="keyword">return</span> -array.length;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; array[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= l) &#123;</span><br><span class="line">        p = l + (target - array[l]) * (r - <span class="number">1</span> - l) / (array[r - <span class="number">1</span>] - array[l]);</span><br><span class="line">        <span class="keyword">if</span> (target == array[p]) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; array[p]) l = p + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = p - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-4-斐波那契查找"><a href="#5-3-4-斐波那契查找" class="headerlink" title="5.3.4 斐波那契查找"></a>5.3.4 斐波那契查找</h2><blockquote>
<p>斐波那契查找原理与前两种类似，仅仅改变了中间节点的位置。<br>其中间节点不是中位或插值，而是位于黄金分割点附近。</p>
</blockquote>
<h1 id="5-4-排序算法"><a href="#5-4-排序算法" class="headerlink" title="5.4 排序算法"></a>5.4 排序算法</h1><blockquote>
<p>排序也叫排序算法。是将一组数据，依指定的顺序进行排列的过程</p>
</blockquote>
<p>排序分为两类：</p>
<ul>
<li>内部排序：将所有要处理的数据加载到内部存储器中进行排序内部排序主要有以下几种：<ul>
<li>插入排序：直接插入排序、希儿排序</li>
<li>选择排序：简单选择排序、堆排序</li>
<li>交换排序：冒泡排序、快速排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
</li>
<li>外部排序：数据量庞大，无法全部加载到内存中，需要借助外部存储进行排序如：合并排序法、直接合并排序法</li>
</ul>
<p><strong>排序算法的时间复杂度：</strong></p>
<table>
<thead>
<tr>
<th>排序法</th>
<th>平均时间</th>
<th>最差情形</th>
<th>稳定性</th>
<th>额外空间</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>稳定</td>
<td>O(1)</td>
<td>n 小时较好</td>
</tr>
<tr>
<td>交换排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>不稳定</td>
<td>O(1)</td>
<td>n 小时较好</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>不稳定</td>
<td>O(1)</td>
<td>n 小时较好</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>稳定</td>
<td>O(1)</td>
<td>大部分已排序时较好</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n × k)</td>
<td>O(n × k)</td>
<td>稳定</td>
<td>O(n)</td>
<td>k 是 “桶” 的个数</td>
</tr>
<tr>
<td>Shell 排序</td>
<td>O(n㏒2n)</td>
<td>O(n㏒22n)</td>
<td>不稳定</td>
<td>O(1)</td>
<td>n 大时较好</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n㏒2n)</td>
<td>O(n2)</td>
<td>不稳定</td>
<td>O(n㏒n)</td>
<td>n 大时较好</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n㏒2n)</td>
<td>O(n㏒2n)</td>
<td>稳定</td>
<td>O(1)</td>
<td>n 小时较好</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n㏒2n)</td>
<td>O(n㏒2n)</td>
<td>不稳定</td>
<td>O(1)</td>
<td>n 大时较好</td>
</tr>
</tbody></table>
<p><strong>稳定性</strong>：排序后，那些原本相等元素的相对顺序不改变</p>
<h2 id="5-4-1-冒泡排序"><a href="#5-4-1-冒泡排序" class="headerlink" title="5.4.1 冒泡排序"></a>5.4.1 冒泡排序</h2><p><strong>冒泡排序</strong>：通过对 <strong>待排序序列</strong> 从后向前遍历，依次比较相邻元素的值。若发现 <strong>逆序</strong> 则交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">/* 共执行 n - 1 轮排序 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; count &lt; array.length; count++)&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">non_exchange</span> <span class="operator">=</span> <span class="literal">true</span>;	<span class="comment">// 该轮排序进行了交换时变为 false</span></span><br><span class="line">        <span class="comment">/* 每轮遍历 n - count 次 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>; n &lt; array.length - count; n++)&#123;</span><br><span class="line">            <span class="comment">/* 当比较时，如果逆序，则交换 */</span></span><br><span class="line">            <span class="keyword">if</span>(array[n] &gt; array[n + <span class="number">1</span>])&#123;</span><br><span class="line">                non_exchange = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[n + <span class="number">1</span>];</span><br><span class="line">                array[n + <span class="number">1</span>] = array[n];</span><br><span class="line">                array[n] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果没有交换过，则提前结束排序过程 */</span></span><br><span class="line">        <span class="keyword">if</span> (non_exchange) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有 n 个元素，就进行 n - 1 轮排序，第 k 轮排序比较 n - k 个元素，并进行最多 n - k 次交换。时间复杂度为 O(n2)</p>
<blockquote>
<p>对随机数组 int[] array（array.length &#x3D; 80000；array[i] ∊ [0, 107)）进行冒泡排序。<br>那个统计时间是：6416 ms</p>
</blockquote>
<h2 id="5-4-2-选择排序"><a href="#5-4-2-选择排序" class="headerlink" title="5.4.2 选择排序"></a>5.4.2 选择排序</h2><p><strong>选择排序</strong>：从 <strong>待排序序列</strong> 中，按指定规则选出某一元素，再依照规定交换位置后达到排序目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">choice_sort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; array.length - <span class="number">1</span>; p++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min_index</span> <span class="operator">=</span> p;		<span class="comment">// loc 指向那个当前找到的最小值的下标</span></span><br><span class="line">        <span class="comment">/* 找出当前剩余元素中的最小值 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p + <span class="number">1</span>; n &lt; array.length; n++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[n] &lt; array[min_index]) min_index = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将找到的最小值与对应位置元素交换 */</span></span><br><span class="line">        <span class="keyword">if</span> (min_index != p) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[min_index];</span><br><span class="line">            array[min_index] = array[p];</span><br><span class="line">            array[p] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有 n 个元素，就进行 n - 1 轮排序，第 k 轮排序比较 n - k 个元素，并进行 1 次交换。时间复杂度为 O(n2)</p>
<blockquote>
<p>对随机数组 int[] array（array.length &#x3D; 80000；array[i] ∊ [0, 107)）进行选择排序。<br>那个统计时间是：1616 ms</p>
</blockquote>
<h3 id="5-4-3-插入排序"><a href="#5-4-3-插入排序" class="headerlink" title="5.4.3 插入排序"></a>5.4.3 插入排序</h3><p><strong>插入排序</strong>：在 <strong>待排序序列</strong> 中的元素，以插入的方式找寻该元素的适当位置，以达到排序目的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert_sort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">/* 数组的前一部分视为有序表，后一部分视为无序表 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>; p &lt; array.length; p++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[p];	<span class="comment">// 那个 无序表首元素 的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">insertPos</span> <span class="operator">=</span> p;		<span class="comment">// 那个 无序表首元素 在有序表的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 逆向遍历那个有序表，以确定该无序表首元素在有序表的位置。</span></span><br><span class="line"><span class="comment">        	到达位置前，将有序表的插入位置后的元素后移 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p - <span class="number">1</span>; n &gt;= <span class="number">0</span>; n--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[n] &lt; temp) <span class="keyword">break</span>;</span><br><span class="line">            array[n + <span class="number">1</span>] = array[n];</span><br><span class="line">            insertPos--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 将该元素插入指定位置 */</span></span><br><span class="line">        array[insertPos] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有 n 个元素，就进行 n - 1 轮排序，第 k 轮排序需要进行 k 次比较、移动或插入。时间复杂度为 O(n2)</p>
<blockquote>
<p>对随机数组 int[] array（array.length &#x3D; 80000；array[i] ∊ [0, 107)）进行插入排序。<br>那个统计时间是：423 ms</p>
</blockquote>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 面向对象编程(基础)</title>
    <url>/2022/09/11/JavaSE/6.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E5%9F%BA%E7%A1%80)/</url>
    <content><![CDATA[<blockquote>
<p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。<br>Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。</p>
</blockquote>
<h1 id="6-1-类与对象-OOP"><a href="#6-1-类与对象-OOP" class="headerlink" title="6.1 类与对象(OOP)"></a>6.1 类与对象(OOP)</h1><blockquote>
<p><code>类</code> 就是数据类型。可以是 <code>int</code> 也可以是 <code>人类</code><br><code>对象</code> 就是其中具体的实例。可以是 <code>100</code> 也可以是 <code>韩顺平</code><br>从 <code>类</code> 到 <code>对象</code>，可以称为 创建一个对象，也可以说 实例化一个对象，或者 把对象实例化</p>
<ol>
<li>类 是抽象的、概念的，代表一类事物</li>
<li>对象 是具体的、实际的，代表一个个具体事物</li>
<li>类 是 对象 的模板，对象 是 类 的一个个体，对应一个实例</li>
</ol>
</blockquote>
<p>下面，我们定义了一个类 Cat 并创建了一些 对象 cat1 cat2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code6_1</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">		cat1.name = <span class="string">&quot;福福&quot;</span>;</span><br><span class="line">		cat1.age = <span class="number">2</span>;</span><br><span class="line">		<span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">		cat2.name = <span class="string">&quot;妞子&quot;</span>;</span><br><span class="line">		cat2.age = <span class="number">1</span>;</span><br><span class="line">		System.out.println(cat1.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-1-1-属性-x2F-成员变量"><a href="#6-1-1-属性-x2F-成员变量" class="headerlink" title="6.1.1 属性&#x2F;成员变量"></a>6.1.1 属性&#x2F;成员变量</h2><blockquote>
<p>从概念或叫法上看：成员变量 &#x3D; 属性 &#x3D; field（字段）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>String name; </code>就是一个成员变量（属性）。<br>属性可以是基本数据类型，也可以是引用数据类型。</p>
<ol>
<li>属性的定义语法同变量。访问修饰符 属性类型 属性名<ul>
<li>访问修饰符：控制属性的访问范围。有四种：<code>publie</code> <code>protected</code> <code>默认(空) private</code></li>
</ul>
</li>
<li>属性的定义类型可以为任意类型，包含 基本类型 或 引用类型</li>
<li>属性如果不赋值，有默认值。</li>
</ol>
<h2 id="6-1-2-创建对象"><a href="#6-1-2-创建对象" class="headerlink" title="6.1.2 创建对象"></a>6.1.2 创建对象</h2><ul>
<li><p><strong>先声明再创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat cat1;  				    <span class="comment">//声明对象cat1</span></span><br><span class="line">cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>();			<span class="comment">//创建对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>直接创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
</li>
</ul>
<ol>
<li>声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。对象的引用，也被称为对象的句柄。</li>
<li>使用 new 运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用。</li>
</ol>
<h2 id="6-1-3-访问对象"><a href="#6-1-3-访问对象" class="headerlink" title="6.1.3 访问对象"></a>6.1.3 访问对象</h2><blockquote>
<p><strong>基本语法</strong>：<code>对象名.属性名</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(cat1.name);</span><br></pre></td></tr></table></figure>
<h2 id="6-1-4-类与对象的内存访问机制"><a href="#6-1-4-类与对象的内存访问机制" class="headerlink" title="6.1.4 类与对象的内存访问机制"></a>6.1.4 类与对象的内存访问机制</h2><blockquote>
<p>栈：一般存放基本数据类型（局部变量）<br>堆：存放对象（如Cat cat1 &#x3D; new Cat()，是在这里开辟的空间）<br>方法区：常量池（常量，比如字符串），类加载信息</p>
</blockquote>
<ol>
<li>创建对象时，先加载 类 信息，然后在 堆 中分配空间，栈 中的对象名被赋予指向那个空间的地址。</li>
<li>之后进行指定初始化。该对象的 属性 中，是 基本数据类型 的直接记录在 堆 中；是 字符串 的记录一个地址，该地址指向 方法区，那里的常量池有该字符串。</li>
</ol>
<h1 id="6-2-成员方法"><a href="#6-2-成员方法" class="headerlink" title="6.2 成员方法"></a>6.2 成员方法</h1><p>在某些情况下，我们需要定义成员方法。比如 <code>Cat</code> 除了有属性（<code>name</code> <code>age</code>）外，还可以有一些行为比如玩耍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回数据类型 方法名(形参列表)&#123;</span><br><span class="line">	方法体语句;</span><br><span class="line">	returen 返回值;			<span class="comment">//返回数据类型是 void 的场合，return语句不是必须的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>方法名必须是一个合法的标识符</p>
</li>
<li><p>返回类型即返回值的类型。如果方法没有返回值，应声明为 void</p>
</li>
<li><p>修饰符段可以有几个不同的修饰符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">strictfp</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;哎咿呀~ 哎咿呀~&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中 public（访问修饰符）、static（static 关键字）、final（final 关键字）</p>
</li>
<li><p>参数列表是传递给方法的参数表。各个元素间以 , 分隔。每个元素由一个类型和一个标识符表示的参数组成。</p>
</li>
</ol>
<p>特别地，<code>参数类型... 标识符</code> 这样的参数被称为可变参数</p>
<ol start="5">
<li>方法体是实际要执行的代码块。方法体一般用 return 作为方法的结束。</li>
</ol>
<p>使用 <code>成员方法</code>，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">	String name;				<span class="comment">//属性 name</span></span><br><span class="line">	<span class="type">int</span> age;					<span class="comment">//属性 age</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;		<span class="comment">//方法 speak()</span></span><br><span class="line">  		System.out.println(<span class="string">&quot;喵~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>方法写好后，不去调用就不会输出</li>
<li>先创建对象，然后调用方法即可</li>
</ol>
</blockquote>
<p>下面，展示一个含有成员方法的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code6_2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">       cat1.speak(<span class="number">10</span>, <span class="number">15</span>);				<span class="comment">//调用 speak 方法，并且给 n1 = 10, n2 = 15</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> cat1.speak2(<span class="number">15</span>, <span class="number">135</span>);	<span class="comment">//调用 speak2 方法,返回值赋给 r</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;	<span class="comment">//(int n1, int n2)形参列表，当前有两个形参 n1,n2</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">       System.out.println(<span class="string">&quot;喵~&quot;</span> + n1 + <span class="string">&quot; + &quot;</span> + n2 +<span class="string">&quot; 的值是：&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">speak2</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;	<span class="comment">//int 表示方法执行后，返回一个 int 值</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">       <span class="keyword">return</span> res;						<span class="comment">//返回 res 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-1-方法的调用机制"><a href="#6-2-1-方法的调用机制" class="headerlink" title="6.2.1 方法的调用机制"></a>6.2.1 方法的调用机制</h2><p>以前文代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">		<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> cat1.speak2(<span class="number">15</span>, <span class="number">135</span>);		</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">speak2</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span>&#123;	</span><br><span class="line">   <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol>
<li>当程序执行到方法时，在 栈 中开辟一个新的 栈空间。该空间里储存 <code>n1 = 15</code> <code>n2 = 135</code>，之后计算并储存结果 <code>res = 150</code></li>
<li>当方法执行完毕，或执行到 <code>return</code> 语句时，就会返回</li>
<li>把 新栈空间 中的 <code>res = 150</code> 返回 main栈 中调用方法的地方</li>
<li>返回后，继续执行该方法的后续代码</li>
</ol>
<h2 id="6-2-2-使用细节"><a href="#6-2-2-使用细节" class="headerlink" title="6.2.2 使用细节"></a>6.2.2 使用细节</h2><ol>
<li>访问修饰符：作用是控制方法的使用范围。<ul>
<li>不写（默认访问控制范围）</li>
<li>public：公共</li>
<li>protected：受保护</li>
<li>private：私有</li>
</ul>
</li>
<li>返回数据类型：<ul>
<li>一个方法最多有一个返回值。要返回多个结果可以使用 数组。</li>
<li>返回类型为任意类型。包括 基本数据类型 和 引用数据类型。</li>
<li>如果方法要求有返回数据类型，则方法体中最后的执行语句必为 <code>return</code> 值，且返回类型必须和 <code>return</code> 的值一致。</li>
<li>如果 返回数据类型 为 <code>void</code>，则可以不写 <code>return </code>语句</li>
</ul>
</li>
<li>方法名：<ul>
<li>遵循驼峰命名法，最好见名知意，表达出该功能的意思。</li>
</ul>
</li>
<li>参数列表（形参列表）：<ul>
<li>一个方法可以有 0 个参数，也可以有多个参数。参数间用 , 间隔。</li>
<li>参数类型可以为任意类型，包含 基本类型 和 引用类型。</li>
<li>调用带参数的方法时，一定对应着 参数列表 传入 相同类型 或 兼容类型 的参数。</li>
<li>方法定义时的参数称为 形式参数 ，简称 形参；方法调用时的参数（传入的参数）称为 实际参数，简称 实参。实参 与 形参 的类型、个数、顺序必须一致。</li>
</ul>
</li>
<li>方法体：<ul>
<li>写完成功能的具体语句。方法中不能再定义方法。即：方法不能嵌套定义。</li>
</ul>
</li>
<li>调用细节：<ul>
<li>同一个类中的方法调用，可以直接调用。</li>
<li>跨类的方法调用，需要创建新对象，然后再调用方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">   m1();					<span class="comment">//同一个类中的方法调用，可以直接调用。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">C1</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C1</span>();</span><br><span class="line">   c.m2();					<span class="comment">//跨类的方法调用，需要创建新对象，然后再调用方法。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="6-2-3-成员方法传参机制"><a href="#6-2-3-成员方法传参机制" class="headerlink" title="6.2.3 成员方法传参机制"></a>6.2.3 成员方法传参机制</h2><p>Java 语言对对象采用的是 <strong>值传递</strong>，方法得到的总是那个传入对象的副本。</p>
<ul>
<li>方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参。</li>
<li>方法可以改变对象参数的状态。引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。但改变那个形参地址指向的场合，实参的指向不会改变。</li>
</ul>
<h1 id="6-3-方法递归调用"><a href="#6-3-方法递归调用" class="headerlink" title="6.3 方法递归调用"></a>6.3 方法递归调用</h1><blockquote>
<p>递归：即方法自己调用自己，每次调用时传入不同变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。</p>
</blockquote>
<blockquote>
<p>下面，示范一个斐波那契数列方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> (fib(n - <span class="number">1</span>)) + (feb(n - <span class="number">2</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-1-使用细节"><a href="#6-3-1-使用细节" class="headerlink" title="6.3.1 使用细节"></a>6.3.1 使用细节</h2><ol>
<li>执行一个方法时，就创建一个新的受保护的独立 栈空间。</li>
<li>方法的局部变量是独立的，不会相互影响。</li>
<li>如果方法中使用的是引用变量，就会共享数据。</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归，会提示 StackOverflowError “死龟”</li>
<li>当一个方法执行完毕，或遇到 return 就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕。</li>
</ol>
<h1 id="6-4-方法重载"><a href="#6-4-方法重载" class="headerlink" title="6.4 方法重载"></a>6.4 方法重载</h1><blockquote>
<p>方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求 形参列表 不一致。这样，减轻了起名和记名的麻烦。</p>
</blockquote>
<p><strong>使用细节:</strong></p>
<ol>
<li>方法名：必须相同</li>
<li>形参列表：必须不同（参数的类型、个数、顺序，这其中至少一个不同）</li>
<li>返回值：无要求</li>
</ol>
<p><strong>签名：</strong><br>由于重载的存在，要完整的描述一个方法，要指定方法名及参数类型。这叫做方法的签名。<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">act</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法的签名分别是：<code>act()</code> 和 <code>act(int n)</code></p>
<h1 id="6-5-可变参数"><a href="#6-5-可变参数" class="headerlink" title="6.5 可变参数"></a>6.5 可变参数</h1><blockquote>
<p>Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p>
</blockquote>
<p>语法：<code>访问修饰符 返回类型 方法名（数据类型... 形参名）&#123;代码块;&#125;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(<span class="type">int</span>... n)</span>&#123;</span><br><span class="line">	<span class="comment">//此时，n 相当于一个 数组。</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> n.length;</span><br><span class="line">	<span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> n[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-5-1-使用细节"><a href="#6-5-1-使用细节" class="headerlink" title="6.5.1 使用细节"></a>6.5.1 使用细节</h2><ol>
<li>可变参数 的实参可以是 0 个，也可以是 任意多 个。</li>
<li>可变参数 的实参可以是数组</li>
<li>可变参数 本质就是数组</li>
</ol>
<p>因此，出现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">met</span><span class="params">(<span class="type">int</span>... n)</span>&#123;				<span class="comment">//这个方法与下面的方法不能构成重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的场合，不能有方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">met</span><span class="params">(<span class="type">int</span>[] n)</span>&#123;				<span class="comment">//这个方法与上面的方法不能构成重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数 在最后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(<span class="type">double</span> dou, <span class="type">int</span>... n)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个形参列表最多出现 一个 可变参数。</p>
</li>
</ol>
<h1 id="6-6-作用域"><a href="#6-6-作用域" class="headerlink" title="6.6 作用域"></a>6.6 作用域</h1><ol>
<li>在 Java 编程中，主要的变量就是 属性（成员变量）和 局部变量。</li>
<li>我们说的 局部变量 一般是指在成员方法中定义的变量。</li>
<li>作用域的分类<ul>
<li>全局变量：也就是 属性，作用域为整个类体</li>
<li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li>
</ul>
</li>
<li>全局变量（属性）可以不赋值直接使用，那个场合有默认值。局部变量必须赋值使用</li>
</ol>
<h2 id="6-6-1-使用细节"><a href="#6-6-1-使用细节" class="headerlink" title="6.6.1 使用细节"></a>6.6.1 使用细节</h2><ol>
<li>属性 和 局部变量 可以重名，访问时遵循就近原则</li>
<li>在同一作用域中，两个局部变量不能重名</li>
<li>属性 的生命周期较长。其伴随对象的创建而创建，伴随对象的销毁而销毁。局部变量 生命周期较短。其伴随代码块的执行而创建，伴随代码块的结束而销毁。</li>
<li>全局变量&#x2F;属性 可以被本类使用，也可以被其他类（通过对象）使用。局部变量 只能被本类的对应方法中调用</li>
<li>全局变量&#x2F;属性 <strong>可以加</strong> 修饰符局部变量 <strong>不能加</strong> 修饰符</li>
</ol>
<h1 id="6-7-构造方法、构造器"><a href="#6-7-构造方法、构造器" class="headerlink" title="6.7 构造方法、构造器"></a>6.7 构造方法、构造器</h1><blockquote>
<p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。</p>
</blockquote>
<p>语法：<code>[修饰符] 方法名(形参列表)&#123;方法体&#125;</code></p>
<ol>
<li>构造器的修饰符可以是默认。也可以是别的</li>
<li>参数列表 规则同 成员方法</li>
</ol>
<p>以下示范一个构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> mun;</span><br><span class="line">    <span class="comment">//下面这块就是构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">T</span><span class="params">(String str, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">		name = str;</span><br><span class="line">		num = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-7-1-使用细节"><a href="#6-7-1-使用细节" class="headerlink" title="6.7.1 使用细节"></a>6.7.1 使用细节</h2><ol>
<li>构造器本质也是方法。所以，可以 构造器重载。</li>
<li>构造器名 和 类名 相同</li>
<li>构造器无返回值</li>
<li>构造器是完成对象的初始化，而不是创建</li>
<li>创建对象时，系统自动调用构造器</li>
<li>如果程序员没有定义构造器，系统会自动给类生成一个无参构造器（默认构造器）</li>
<li>一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器</li>
</ol>
<h2 id="6-7-2-流程分析"><a href="#6-7-2-流程分析" class="headerlink" title="6.7.2 流程分析"></a>6.7.2 流程分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Amy&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String pName, <span class="type">int</span> pAge)</span>&#123;</span><br><span class="line">		name = pName;</span><br><span class="line">		age = pAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>加载 类信息（方法区）</li>
<li>在 <strong>堆</strong> 中开辟空间（地址）</li>
<li>完成对象初始化<ul>
<li>首先默认初始化。<code>age = 0;</code> <code>name = null</code></li>
<li>之后显式初始化。<code>age = 20;</code> <code>name = null</code>其中，显式初始化和代码块初始化按编写的先后顺序依次进行。</li>
<li>之后构造器的初始化。<code>age = 10; name = &quot;Amy&quot;</code></li>
</ul>
</li>
<li>把对象在 <strong>堆</strong> 中的 <strong>地址</strong>，返回给 <code>p1</code></li>
</ol>
<h1 id="6-8-this关键字"><a href="#6-8-this关键字" class="headerlink" title="6.8 this关键字"></a>6.8 <code>this</code>关键字</h1><blockquote>
<p>JVM 会给每个对象分配 this 代表当前对象。<br>相当于在 堆 中，this 指向自己（对象）<br>在类定义的方法中，Java 会自动用 this 关键字把所有变量和方法引用结合在一起。<br>遇到有同名的局部变量的场合，需要程序员加入 this 关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">(<span class="type">int</span> n)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个类的 <code>act()</code> 方法实际有 2 个参数。对其调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Example</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exmaple</span>();</span><br><span class="line">e.act(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>可见，出现在方法名前的参数 e，以及出现在方法名后的括号中的参数 100<br>出现在方法名前的参数被称为 <strong>隐式参数</strong>（也称为 方法调用的 目标 或 接收者）<br>出现在方法名后的参数被称为 <strong>显式参数</strong>，就是所谓的实参<br>在每一个方法中，用 this 指代隐式参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">act</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，再以相同方式调用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e.act(<span class="number">100</span>);					<span class="comment">// &lt;———— 相当于 e.n = 100;</span></span><br></pre></td></tr></table></figure>
<h2 id="6-8-1-使用方法"><a href="#6-8-1-使用方法" class="headerlink" title="6.8.1 使用方法"></a>6.8.1 使用方法</h2><ol>
<li><code>this</code> 关键字可以用来访问本类的属性、方法、构造器</li>
<li><code>this</code> 用于区分当前类的 属性 和 局部变量</li>
<li>访问本类中成员方法的语法：<code>this.方法名</code></li>
<li>访问构造器的语法：<code>this(参数列表);</code></li>
<li>注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。</li>
<li><code>this</code> 不能在类定义的 外部 使用，只能在类定义的 方法中 使用</li>
</ol>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 面向对象编程(中级)</title>
    <url>/2022/09/11/JavaSE/7.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E4%B8%AD%E7%BA%A7)/</url>
    <content><![CDATA[<blockquote>
<p>IDE：集成开发环境</p>
<ul>
<li>IDEA</li>
<li>Eeclipse：一个开源的、基于 Java 的可扩展开发平台。是由 IBM 公司开发，在 2001 年 11 月贡献给开源社区的，目前最优秀的 Java 开发 IDE 之一。</li>
</ul>
</blockquote>
<h1 id="7-1-IDEA-的使用"><a href="#7-1-IDEA-的使用" class="headerlink" title="7.1 IDEA 的使用"></a>7.1 IDEA 的使用</h1><blockquote>
<p>IDEA：全程 IntelliJ IDEA。在业界被公认为最好的 Java 开发工具。是捷克 JetBrains 公司的产品。除了 Java 开发，还支持 HTML，CSS，PHP，MySQL，Python 等。<a href="https://www.jetbrains.com/zh-cn/idea/download/#section=windows">下载地址</a></p>
</blockquote>
<h2 id="7-1-1-常用快捷键"><a href="#7-1-1-常用快捷键" class="headerlink" title="7.1.1 常用快捷键"></a>7.1.1 常用快捷键</h2><ul>
<li>删除当前行：<code>ctrl + Y</code></li>
<li>复制当前行：<code>ctrl + D</code></li>
<li>补全代码：<code>alt + /</code></li>
<li>添加 &#x2F; 取消注释：<code>ctrl + /</code></li>
<li>导入该行需要的类：<code>alt + enter</code></li>
<li>快速格式化代码：<code>ctrl + alt + L</code></li>
<li>快速运行程序：<code>shift + F10</code>（我改成了<code>alt + R</code>）</li>
<li>生成构造器：<code>alt + insert</code></li>
<li>查看一个类的层级关系：<code>ctrl + H</code></li>
<li>定位一个方法：把光标放在一个方法上，按<code> ctrl + B</code></li>
<li>自动分配变量名：在后面加上<code> .var</code></li>
<li>查看模板快捷键：<code>ctrl + J</code></li>
<li>快速环绕代码：<code>ctrl + alt + T</code></li>
</ul>
<h2 id="7-1-2-模板快捷键"><a href="#7-1-2-模板快捷键" class="headerlink" title="7.1.2 模板快捷键"></a>7.1.2 模板快捷键</h2><ul>
<li><code>main</code>：<code>public static void main(String[] args) &#123;&#125;</code></li>
<li><code>sout</code>：<code>System.out.println();</code></li>
<li><code>fori</code>：<code>for (int i = 0; i &lt; ; i++) &#123;&#125;</code></li>
<li><code>xxx.for</code>：<code>for(int i = 0; i &lt; xxx; i++) &#123;&#125;</code></li>
</ul>
<p>更多的请在 File - Settings - Editor - Live template 中查看或添加或者，通过下列快捷键查看</p>
<ul>
<li><code>ctrl + J</code>：查看模板快捷键</li>
</ul>
<h1 id="7-2-包"><a href="#7-2-包" class="headerlink" title="7.2 包"></a>7.2 包</h1><blockquote>
<p>包的作用：1. 区分相同名字的类 2. 当类很多时，便于管理 3. 控制访问范围<br>语法：<code>package com.name</code> 其中 <code>com name</code> 分别是 一级 和 二级目录，用 . 分隔<br>包的本质：就是创建不同 文件夹&#x2F;目录 来保存 类 文件</p>
</blockquote>
<p>如何使用包中的对象：</p>
<ol>
<li><p>先引入包，之后创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.name.T;</span><br><span class="line">...</span><br><span class="line"><span class="type">T</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>不引入包，而在创建对象时写全路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.name.<span class="type">T</span> <span class="variable">tools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.name.T();</span><br></pre></td></tr></table></figure>
<p><strong>命名规则：</strong></p>
</li>
</ol>
<ul>
<li>只能包含 数字<code> 1 2 3</code>、字母 <code>a b A b</code>、下划线 <code>_</code>、小圆点 <code>.</code></li>
<li>不能用 数字 开头。每级目录都不能</li>
</ul>
<p><strong>命名规范：</strong></p>
<ul>
<li>全小写字母 + 小圆点</li>
<li><code>com.公司名.项目名.业务模块</code></li>
</ul>
<p><strong>常用的包：</strong><br><code>java.lang</code>：基本包，默认引入，不需要再引入<br><code>java.util</code>：系统提供的工具包。工具类。<br><code>java.net</code>：网络包，网络开发。<br><code>java.awt</code>：Java 的界面开发，GUI。<br><strong>引入包：</strong></p>
<ul>
<li>只引入该包下的一个类：<code>import java.util.Scanner</code></li>
<li>引入该包的所有内容（不建议）：<code>import java.util.*</code></li>
</ul>
<p><strong>使用细节：</strong></p>
<ol>
<li><code>package</code> 的作用是声明当前类所在的包，要放在 类 的 最上面。一个 类 中最多有一句 <code>package</code></li>
<li><code>import</code> 放在<code> package</code> 下面，类定义 前面。可以有多条语句，且没有顺序要求</li>
<li>编译器编译时 <strong>不会</strong> 检查目录结构。即使一个包处于错误的目录下（只要其不依赖其他包）也可能通过编译。但是，虚拟机会找不到该包，最终程序无法运行。</li>
<li>从 1.2 版本开始，用户不能再把包放在 java. 开头的目录下了。若如此做，这些包会被禁止加载。</li>
</ol>
<h2 id="7-4-1-静态导入"><a href="#7-4-1-静态导入" class="headerlink" title="7.4.1 静态导入"></a>7.4.1 静态导入</h2><blockquote>
<p>有一种import 语句允许导入静态方法和字段，而不只是类</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure>
<p>这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> pow(<span class="number">10</span>, <span class="number">5</span>);					<span class="comment">// &lt;———— 本来是 double n = Math.pow(10, 5);</span></span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> PI;							<span class="comment">// &lt;———— 本来是 double pi = Math.PI;</span></span><br></pre></td></tr></table></figure>
<h1 id="7-3-访问修饰符"><a href="#7-3-访问修饰符" class="headerlink" title="7.3 访问修饰符"></a>7.3 访问修饰符</h1><h2 id="7-3-1-访问权限特点"><a href="#7-3-1-访问权限特点" class="headerlink" title="7.3.1 访问权限特点"></a>7.3.1 访问权限特点</h2><p>Java 提供 4 种 访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）</p>
<ul>
<li>公开级别：<code>public</code>，对外公开。</li>
<li>受保护级别：<code>protected</code>，对 子类 和 同一个包中的类 公开。</li>
<li>默认级别：没有修饰符号，向 同一个包的类 公开。</li>
<li>私有级别：<code>private</code>，只有 同类 可以访问，不对外公开。<table>
<thead>
<tr>
<th><strong>(⌐■_■)</strong></th>
<th><strong>默认（无修饰符）</strong></th>
<th><strong>private</strong></th>
<th><strong>protected</strong></th>
<th><strong>public</strong></th>
</tr>
</thead>
<tbody><tr>
<td>本类</td>
<td>可</td>
<td>可</td>
<td>可</td>
<td>可</td>
</tr>
<tr>
<td>同包中的子类</td>
<td>可</td>
<td>不可以</td>
<td>可</td>
<td>可</td>
</tr>
<tr>
<td>同包的非子类</td>
<td>可</td>
<td>不可以</td>
<td>可</td>
<td>可</td>
</tr>
<tr>
<td>其他包的子类</td>
<td>不可以</td>
<td>不可以</td>
<td>可</td>
<td>可</td>
</tr>
<tr>
<td>其他包的非子类</td>
<td>不可以</td>
<td>不可以</td>
<td>不可以</td>
<td>可</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="7-3-2-使用说明"><a href="#7-3-2-使用说明" class="headerlink" title="7.3.2 使用说明"></a>7.3.2 使用说明</h2><ol>
<li>修饰符可以修饰类中的 属性、成员方法 及 类</li>
<li>只有 默认 和 <code>public</code> 才能修饰 类，并遵循上述访问权限特点</li>
<li>成员方法 的访问规则和 属性 相同</li>
<li>private 修饰的变量可以被 任意本对象同类的对象访问</li>
</ol>
<h1 id="7-4-封装"><a href="#7-4-封装" class="headerlink" title="7.4 封装"></a>7.4 封装</h1><blockquote>
<p>封装（encapsulation）就是把抽象出的 数据[属性] 和对数据的 操作[方法] 封装在一起。数据 被保护在内部，程序的其他部分只有通过被授权的 操作[方法]，才能对数据进行操作。</p>
</blockquote>
<p>封装的好处：</p>
<ul>
<li>隐藏实现细节</li>
<li>可以对数据进行验证，保证安全合理</li>
</ul>
<p><strong>实现步骤：</strong></p>
<ol>
<li>将属性私有化 <code>private</code></li>
<li>提供一个公共的 <code>set</code> 方法，用于对属性判断并赋值</li>
<li>提供一个公共的 <code>get</code> 方法，用于获取属性的值</li>
</ol>
<p><strong>编译多个源文件：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac MyClass.java</span><br></pre></td></tr></table></figure>
<p>该文件中使用了其他类时，Java 编译器会查找对应名称的 .class 文件。没有找到的场合，转而寻找 .java 文件，并对其编译。倘若 .java 文件相较原有 .class 文件更新，编译器也会自动重新编译该文件。</p>
<h2 id="7-4-1-静态导入-1"><a href="#7-4-1-静态导入-1" class="headerlink" title="7.4.1 静态导入"></a>7.4.1 静态导入</h2><blockquote>
<p>有一种import语句允许导入静态方法和字段，而不只是类。</p>
</blockquote>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure>
<p>这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">n</span> <span class="operator">=</span> pow(<span class="number">10</span>, <span class="number">5</span>);					<span class="comment">// &lt;———— 本来是 double n = Math.pow(10, 5);</span></span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> PI;							<span class="comment">// &lt;———— 本来是 double pi = Math.PI;</span></span><br></pre></td></tr></table></figure>
<h2 id="7-4-2-JAR-文件"><a href="#7-4-2-JAR-文件" class="headerlink" title="7.4.2 JAR 文件"></a>7.4.2 JAR 文件</h2><blockquote>
<p>为了避免向用户提供包含大量类文件的复杂目录结构，可以将 Java 程序打包成 JAR （Java 归档）文件。<br>一个 JAR 文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。<br>JAR 文件是压缩的。其使用了 ZIP压缩格式。</p>
</blockquote>
<p><strong>创建 JAR：</strong><br>使用 jar 工具以制作 JAR 文件。该工具在 jdk&#x2F;bin 目录下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jar cvf 包名 文件名<span class="number">1</span> 文件名<span class="number">2</span> ...</span><br></pre></td></tr></table></figure>
<p>关于 jar 工具的各种指令，还是自己去百度一下吧</p>
<h1 id="7-5-继承"><a href="#7-5-继承" class="headerlink" title="7.5 继承"></a>7.5 继承</h1><blockquote>
<p>继承：能解决代码复用，让我们的编程更接近人类思维。当多个类存在相同的 属性（变量）和 方法 时，可以从这些类中抽象出 父类（基类&#x2F;超类）。在 父类 中定义这些属性·方法，所有的子类不需要重新定义这些属性和方法，只需要通过 <code>extends</code> 来声明继承父类即可。<br>通过继承的方法，代码的复用性提高了，代码的维护性和拓展性也提高了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;&#125;;				<span class="comment">// Son 类继承了 Father 类</span></span><br></pre></td></tr></table></figure>
<p>定义类时可以指明其父类，也能不指明。不指明的场合，默认继承 Object 类。<br>所有类有且只有一个父类。Object 是所有类的直接或间接父类。只有 Object 本身没有父类。</p>
<h2 id="7-5-1-使用细节"><a href="#7-5-1-使用细节" class="headerlink" title="7.5.1 使用细节"></a>7.5.1 使用细节</h2><ol>
<li>子类 继承了所有属性和方法，但私有（<code>private</code>）的 属性·方法 不能在 子类 直接访问。要调用父类提供的 公共（<code>public</code>）等方法 访问。</li>
<li>子类 必须调用 父类 的 构造器，完成 父类 的 初始化。</li>
<li>当创建 子类对象 时，不管使用 子类的哪个构造器，默认情况下总会调用 父类的无参构造器。如果 父类 没有提供 无参构造器，则必须在 子类的构造器 中用 <code>super</code> 去指定使用 父类的哪个构造器 完成 对父类的初始化。否则编译不能通过。</li>
<li>如果希望指定调用 父类的某构造器，则显式地调用一下：<code>super(形参列表);</code></li>
<li><code>super</code> 在使用时，必须放在构造器第一行。<code>super</code> 只能在构造器中使用。</li>
<li>由于 <code>super </code>与 <code>this</code> 都要求放在第一行，所以此两个方法不能同时存在于同一构造器。</li>
<li>Java 所有的类都是 <code>Object</code> 的子类。换言之，<code>Object</code> 是所有类的父类。</li>
<li>父类构造器的调用不限于直接父类，将持续向上直至追溯到顶级父类 <code>Object</code></li>
<li>子类 最多只能直接继承 一个 父类。即，Java 中是 单继承机制。</li>
<li>不能滥用继承。子类 和 父类 之间必须满足 is - a 的逻辑关系。</li>
</ol>
<h2 id="7-5-2-继承的本质"><a href="#7-5-2-继承的本质" class="headerlink" title="7.5.2 继承的本质"></a>7.5.2 继承的本质</h2><ul>
<li>内存布局：<ol>
<li>在 方法区，自顶级父类起，依次加载 类信息。</li>
<li>在 堆 中开辟一个空间，自顶级父类起，依次创建并初始化各个类包含的所有属性信息。</li>
<li>在 栈 中存放该空间的 地址。</li>
</ol>
</li>
<li>如何查找信息？<ol>
<li>查看该子类是否有该属性。如果该子类有这个属性且可以访问，则返回信息。</li>
<li>子类没有该属性的场合，查看父类是否有该属性。如有且可访问，则返回信息。如不可访问，则报错。</li>
<li>父类也没有该属性的场合，继续查找上级父类，直到顶级父类（Object）。</li>
<li>如需调用某个特定类包含的特定信息，可以调用该类提供的方法。</li>
</ol>
</li>
</ul>
<h2 id="7-5-3-super关键字"><a href="#7-5-3-super关键字" class="headerlink" title="7.5.3 super关键字"></a>7.5.3 <code>super</code>关键字</h2><blockquote>
<p><code>super</code> 代表父类的引用。用于访问父类的 属性、方法、构造器。</p>
</blockquote>
<p><strong>super 的使用：</strong></p>
<ul>
<li><code>super.属性名</code>：访问父类的属性。不能访问父类的私有（private）属性。</li>
<li><code>super.方法名(形参列表)</code>：访问父类的方法。不能访问父类的私有（private）方法。</li>
<li><code>super(参数列表);</code>：访问父类的构造器。此时，super 语句必须放在第一句。</li>
</ul>
<p><strong>使用细节：</strong></p>
<ol>
<li>调用父类构造器，好处是分工明确。父类属性由父类初始化，子类由子类初始化。</li>
<li>子类中由和父类中成员（属性和方法）重名时，要调用父类成员必须用 super。没有重名的场合，<code>super</code>、<code>this</code> 及直接调用的效果相同。</li>
<li><code>super</code> 的访问不限于直接父类。如果爷爷类和本类中都有同名成员也能使用。如果多个基类中都有同名成员，则遵循就近原则。</li>
</ol>
<h2 id="7-5-4-方法重写-x2F-覆盖"><a href="#7-5-4-方法重写-x2F-覆盖" class="headerlink" title="7.5.4 方法重写&#x2F;覆盖"></a>7.5.4 方法重写&#x2F;覆盖</h2><blockquote>
<p>方法重写&#x2F;覆盖（Override）：如若子类有一个方法，和父类的某方法的 名称、返回类型、参数 一样，那么我们就说该子类方法 覆盖 了那个父类方法。</p>
</blockquote>
<p><strong>使用细节：</strong></p>
<ol>
<li>子类方法的参数，方法名称，要和父类方法完全一致。</li>
<li>子类方法的返回类型需和父类方法 一致，或者是父类返回类型的子类。</li>
<li>子类方法 <strong>不能缩小</strong> 父类方法的访问范围（访问修饰符）。</li>
</ol>
<h1 id="7-6-多态"><a href="#7-6-多态" class="headerlink" title="7.6 多态"></a>7.6 多态</h1><blockquote>
<p>多态：方法 或 对象 有多种形态。多态 是面向对象的第三大特征，是建立在 封装 和 继承 的基础之上的</p>
</blockquote>
<h2 id="7-6-1-多态的体现"><a href="#7-6-1-多态的体现" class="headerlink" title="7.6.1 多态的体现"></a>7.6.1 多态的体现</h2><ol>
<li>方法的多态：重写 和 重载 体现了 方法的多态。</li>
<li><strong>对象的多态：</strong><ul>
<li>一个对象的 编译类型 和 运行类型 可以不一致。<code>Animal animal = new Dog();</code>上例，编译类型是 <code>Animal</code>，运行类型是子类 <code>Dog</code>。</li>
<li>编译类型在定义对象时就确定了，不能改变。</li>
<li>运行类型是可以变化的。上例中，再让 <code>animal = new Cat();</code>，这样，运行类型变为了 <code>Cat</code></li>
<li>编译类型看定义时 <code>=</code> 的左边，运行类型看 <code>=</code> 的右边。</li>
</ul>
</li>
</ol>
<h2 id="7-6-2-使用细节"><a href="#7-6-2-使用细节" class="headerlink" title="7.6.2 使用细节"></a>7.6.2 使用细节</h2><ol>
<li>多态的前提：两个对象 &#x2F; 类存在继承关系。</li>
<li>多态的向上转型：<ul>
<li>本质：父类的引用指向了子类的对象。（如 [ 7.6.1.2 ]）</li>
<li>语法：<code>父类类型 引用名 = new 子类类型(参数列表);</code></li>
<li>编译类型看左边，运行类型看右边。</li>
<li>可以调用父类中的所有成员，但不能调用子类特有的成员，而且需要遵守访问权限。因为在编译阶段，能调用哪些成员是由编译类型决定的。</li>
<li>最终的运行结果要看子类的具体实现。即从子类起向上查找方法调用（与 [ 7.5.2 ] 规则相同）。</li>
</ul>
</li>
<li>多态的向下转型：<ul>
<li>语法：<code>子类类型 引用名 = (子类类型)父类引用;</code></li>
</ul>
</li>
</ol>
<p>[7.6.2.2] 的例子里，向下转型。这个语法其实和 [2.8.2 强制类型转换] 很像。<br><code>Dog dog = (Dog)animal;</code></p>
<ul>
<li>只能强转父类的引用，不能强转父类的对象。</li>
<li>要求父类的引用必须指向的是当前目标类型的对象。即上例中的 animal 运行类型需是 Dog</li>
<li>向下转型后，可以调用子类类型中的所有成员。</li>
</ul>
<ol start="4">
<li>属性没有重写一说。<strong>和 方法 不同，属性的值 看编译类型。</strong></li>
<li>instanceof 比较操作符。用于判断对象类型是否是某类型或其子类型。此时判断的是 <strong>运行类型。</strong></li>
</ol>
<h2 id="7-6-3-理解方法调用"><a href="#7-6-3-理解方法调用" class="headerlink" title="7.6.3 理解方法调用"></a>7.6.3 理解方法调用</h2><p>在对象上调用方法的过程如下：</p>
<ol>
<li>编译器查看对象的声明类型和方法名。该类和其父类中，所有同名方法（包括参数不同的方法）都被列举。至此，编译器已经知道所有可能被调用的方法。</li>
<li>编译器确认方法调用中提供的参数类型。那些列举方法中存在参数类型完全匹配的方法时，即调用该方法。没有发现匹配方法，抑或是发现经过类型转换产生了多个匹配方法时，就会报错至此，编译器已经知道要调用方法的名字和参数类型</li>
<li>如若是 private 方法、static 方法、final 方法、构造器，那么编译器将能准确知道要调用哪个方法。这称为 <strong>静态绑定</strong> 与之相对的，如果调用方法依赖于隐式参数类型，那么必须在运行时 <strong>动态绑定</strong></li>
<li>程序运行并采取动态绑定方法时，JVM 将调用那个** 实际类型** 对应的方法。</li>
</ol>
<p>倘若每次调用方法都进行以上搜索，会造成庞大的时间开销。为此，JVM 预先为每个类计算了** 方法表。**<br>方法表中列举了所有方法的签名与实际调用的方法。如此，每次调用方法时，只需查找该表即可。<br>特别地，使用 super 关键字时，JVM 会查找其父类的方法表。<br><strong>动态绑定机制：</strong></p>
<ul>
<li>当调用对象方法的时候，该方法和该对象（隐式参数）的内存地址&#x2F;运行类型绑定。</li>
<li>当调用对象属性时，没有动态绑定机制。于是哪里声明，哪里调用。</li>
</ul>
<h1 id="7-7-Object类"><a href="#7-7-Object类" class="headerlink" title="7.7 Object类"></a>7.7 Object类</h1><h2 id="7-7-1-equals-方法"><a href="#7-7-1-equals-方法" class="headerlink" title="7.7.1 equals 方法"></a>7.7.1 equals 方法</h2><blockquote>
<p><code>对象名.equals(形参);</code></p>
</blockquote>
<ul>
<li><code>==</code>：既可以判断基本类型，也可以判断引用类型。如果判断基本类型，判断的是值是否相等。如果判断引用类型，判断的是地址是否相等。</li>
<li><code>equals</code>：是 Object 中的方法，只能判断引用类型。默认判断地址是否相等，但子类中往往重写该代码，以判断内容是否相等。</li>
</ul>
<h2 id="7-7-2-hashCode-方法"><a href="#7-7-2-hashCode-方法" class="headerlink" title="7.7.2 hashCode 方法"></a>7.7.2 hashCode 方法</h2><blockquote>
<p><code>对象名.hashCode();</code><br>返回对象的 哈希码值</p>
</blockquote>
<ol>
<li>提高哈希结构的容器的效率。</li>
<li>两个引用，若是指向同一对象，则哈希值必定相同，反之不同（但，严谨的说，也有极低概率发生碰撞）</li>
<li>哈希值是根据地址生成的，因而，哈希值不能等同于地址</li>
<li>如何重写该方法：后面学习 [ 集合 ] 时说明</li>
</ol>
<h2 id="7-7-3-toString-方法"><a href="#7-7-3-toString-方法" class="headerlink" title="7.7.3 toString 方法"></a>7.7.3 toString 方法</h2><blockquote>
<p><code>对象名.toString();</code></p>
</blockquote>
<ol>
<li>默认返回：<code>全类名@哈希值的十六进制;</code><ul>
<li>全类名：即包名+类名。比如 <code>com.prictice.codes.Person</code></li>
</ul>
</li>
<li>重写该方法，打印对象或拼接对象时，都会自动调用该对象的 <code>toString</code></li>
<li>当直接调用对象时，默认调用该方法。</li>
</ol>
<h2 id="7-7-4-findlize-方法"><a href="#7-7-4-findlize-方法" class="headerlink" title="7.7.4 findlize 方法"></a>7.7.4 findlize 方法</h2><ol>
<li>当对象被回收时，系统会自动调用该对象的 <code>finalize</code> 方法。子类可以重写该方法，做一些释放资源的操作。</li>
<li>何时被回收：当某对象没有任何引用时，JVM 就认为该对象是一个垃圾对象，就会（在算法决定的某个时刻）使用垃圾回收机制来销毁该对象。在销毁该对象前，会调用 <code>finalize</code> 方法。</li>
<li>垃圾回收机制的调用，是由系统决定。也可以通过 <code>System.gc(); </code>主动触发垃圾回收机制。这个方法一经调用就会继续执行余下代码，而不会等待回收完毕。</li>
<li>实际开发中，几乎不会运用该方法。</li>
</ol>
<h1 id="7-8-断点调试-Debug"><a href="#7-8-断点调试-Debug" class="headerlink" title="7.8 断点调试(Debug)"></a>7.8 断点调试(Debug)</h1><blockquote>
<p>断点调试：在程序某一行设置一个断点，调试时，代码运行至此就会停住，然后可以一步一步往下调试。调试过程中可以看各个变量当前的值。如若出错，则测试到该出错代码行即显示错误并停下。进行分析从而找到这个 Bug。<br>调试过程中是运行状态，所以，是以对象的 运行类型 执行。<br>断点调试是程序员必须掌握的技能，能帮助我们查看 Java 底层源代码的执行过程，提高程序员 Java 水平。</p>
</blockquote>
<p>快捷键如下</p>
<ul>
<li>跳入：<code>F7</code></li>
<li>跳过：<code>F8</code></li>
<li>跳出：<code>shift + F8</code></li>
<li>resume，执行到下一个断点：<code>F9</code></li>
</ul>
<h1 id="7-9-零钱通程序"><a href="#7-9-零钱通程序" class="headerlink" title="7.9 零钱通程序"></a>7.9 零钱通程序</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wlm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wlm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallChangeApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmallChangeOop</span> <span class="variable">smallChangeOop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmallChangeOop</span>();</span><br><span class="line">        smallChangeOop.menu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wlm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallChangeOop</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">details</span> <span class="operator">=</span> <span class="string">&quot;------------零钱通明细------------&quot;</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 菜单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">menu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n=============零钱通菜单=============&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t 1 零 钱 通 明 细&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t 2 收 益 入 账&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t 3 消      费&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t 4 退      出&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;请选择(1-4): &quot;</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    income();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    pay();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    exit();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 零钱通明细</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(details);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收入细明</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">income</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入入账金额： &quot;</span>);</span><br><span class="line">        money = scanner.nextDouble();</span><br><span class="line">        <span class="keyword">if</span>(money &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;存不进去，请输入正确金额&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        balance += money;</span><br><span class="line">        details += <span class="string">&quot;\n收益入账\t+&quot;</span> + money + <span class="string">&quot;\t&quot;</span> + simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\t&quot;</span> + balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">note</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入消费金额 :&quot;</span>);</span><br><span class="line">        money = scanner.nextDouble();</span><br><span class="line">        <span class="keyword">if</span> (money &lt;= <span class="number">0</span> &amp;&amp; money &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;太贵了买不起，只能买1-100块钱的东西&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(balance &lt; money) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;买不起，存款不足啊！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入消费说明：&quot;</span>);</span><br><span class="line">        note = scanner.next();</span><br><span class="line">        balance -= money;</span><br><span class="line">        details += <span class="string">&quot;\n&quot;</span>+note+<span class="string">&quot;\t-&quot;</span> + money + <span class="string">&quot;\t&quot;</span> + simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\t&quot;</span> + balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退出程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;退出系统(y/n)? &quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">choice</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;y&quot;</span>.equals(choice)) &#123;</span><br><span class="line">                loop = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;n&quot;</span>.equals(choice)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入有误,请重新输入！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wlm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> wlm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallChangeSys</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择菜单并且给出相应的提示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 零钱通明细</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">details</span> <span class="operator">=</span> <span class="string">&quot;------------零钱通明细------------&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 收益入账</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">note</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n=============零钱通菜单=============&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t 1 零 钱 通 明 细&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t 2 收 益 入 账&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t 3 消      费&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t 4 退      出&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">&quot;请选择(1-4): &quot;</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    System.out.println(details);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入入账金额： &quot;</span>);</span><br><span class="line">                    money = scanner.nextDouble();</span><br><span class="line">                    <span class="keyword">if</span>(money &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;存不进去，请输入正确金额&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    balance += money;</span><br><span class="line">                    details += <span class="string">&quot;\n收益入账\t+&quot;</span> + money + <span class="string">&quot;\t&quot;</span> + simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\t&quot;</span> + balance;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入消费金额 :&quot;</span>);</span><br><span class="line">                    money = scanner.nextDouble();</span><br><span class="line">                    <span class="keyword">if</span> (money &lt;= <span class="number">0</span> &amp;&amp; money &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;太贵了买不起，只能买1-100块钱的东西&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(balance &lt; money) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;买不起，存款不足啊！&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(<span class="string">&quot;请输入消费说明：&quot;</span>);</span><br><span class="line">                    note = scanner.next();</span><br><span class="line">                    balance -= money;</span><br><span class="line">                    details += <span class="string">&quot;\n&quot;</span>+note+<span class="string">&quot;\t-&quot;</span> + money + <span class="string">&quot;\t&quot;</span> + simpleDateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\t&quot;</span> + balance;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        System.out.print(<span class="string">&quot;退出系统(y/n)? &quot;</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">choice</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;y&quot;</span>.equals(choice)) &#123;</span><br><span class="line">                            loop = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;n&quot;</span>.equals(choice)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;输入有误,请重新输入！&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;您的选择有误，请重新选择&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (loop);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;已成功退出零钱通系统~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 房屋出租系统</title>
    <url>/2022/09/11/JavaSE/8.%20%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%88%BF%E5%B1%8B%E5%87%BA%E7%A7%9F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>crud： c[create] r[read] u[update] d[delete]</p>
</blockquote>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>该项目是一阶段毕业作业，用于练习java的crud,同时使用了少量的框架思想。</p>
<h1 id="实体类House"><a href="#实体类House" class="headerlink" title="实体类House"></a>实体类House</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wlm.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="comment">// 编号 房主 电话 地址 月租 状态(已出租/未出租)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rent;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">House</span><span class="params">(<span class="type">int</span> id, String name, String phone, String address, <span class="type">int</span> rent, String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.rent = rent;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRent</span><span class="params">(<span class="type">int</span> rent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id +</span><br><span class="line">                <span class="string">&quot;\t\t&quot;</span> + name+</span><br><span class="line">                <span class="string">&quot;\t\t&quot;</span> + phone +</span><br><span class="line">                <span class="string">&quot;\t\t&quot;</span> + address +</span><br><span class="line">                <span class="string">&quot;\t\t&quot;</span> + rent +</span><br><span class="line">                <span class="string">&quot;\t\t&quot;</span> + state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="服务层HouseService"><a href="#服务层HouseService" class="headerlink" title="服务层HouseService"></a>服务层HouseService</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wlm.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wlm.domain.House;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> House[] houses;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">HouseNums</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseService</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        houses = <span class="keyword">new</span> <span class="title class_">House</span>[size];</span><br><span class="line">        houses[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">House</span>(<span class="number">0</span>,<span class="string">&quot;King&quot;</span>,<span class="string">&quot;1888&quot;</span>,<span class="string">&quot;河南&quot;</span>,<span class="number">2000</span>,<span class="string">&quot;未出租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> House[] list() &#123;</span><br><span class="line">        <span class="keyword">return</span> houses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(House house)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(HouseNums == houses.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组已经满了，不可以再添加了&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        house.setId(HouseNums);</span><br><span class="line">        houses[HouseNums++] = house;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delect</span><span class="params">(<span class="type">int</span> delectId)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到删除房屋信息对应的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; HouseNums; i++) &#123;</span><br><span class="line">            <span class="comment">// 删除的id匹配</span></span><br><span class="line">            <span class="keyword">if</span>(delectId == houses[i].getId()) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到之后删除</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i &lt; HouseNums - <span class="number">1</span> ; i++) &#123;</span><br><span class="line">            houses[i] = houses[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        houses[--HouseNums-<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; HouseNums; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(id == houses[i].getId()) &#123;</span><br><span class="line">                <span class="keyword">return</span> houses[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="视图层HouseView"><a href="#视图层HouseView" class="headerlink" title="视图层HouseView"></a>视图层HouseView</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wlm.view;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wlm.domain.House;</span><br><span class="line"><span class="keyword">import</span> com.wlm.service.HouseService;</span><br><span class="line"><span class="keyword">import</span> com.wlm.utils.Utility;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.rmi.CORBA.Util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HouseService</span> <span class="variable">houseService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseService</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主菜单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mainMenu</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;=============房屋出租系统菜单=============&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t1 新 增 房 源&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t2 查 找 房 源&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t3 删 除 房 屋 信 息&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t4 修 改 房 屋 信 息&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t5 房 屋 列 表&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t\t\t6 退       出&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入您的选择(1-6) : &quot;</span>);</span><br><span class="line">            key = Utility.readChar();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    addHouse();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                    findHouse();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">                    delectHouse();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">                    updateHouse();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">                    listHouse();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">                    exit();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (loop);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 房屋列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n==========房屋列表==========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;编号\t\t房主\t\t电话\t\t地址\t\t月租\t\t状态(已出租/未出租)&quot;</span>);</span><br><span class="line">        House[] list = houseService.list();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========显示完毕==========\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加房屋</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n==========添加房屋==========&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;姓名：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Utility.readString(<span class="number">8</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;电话：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> Utility.readString(<span class="number">12</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;地址：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> Utility.readString(<span class="number">16</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;月租：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rent</span> <span class="operator">=</span> Utility.readInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;状态：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> Utility.readString(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 创建一个新的House对象，注意id是系统分配的</span></span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>(<span class="number">0</span>, name, phone, address, rent, state);</span><br><span class="line">        <span class="keyword">if</span>(houseService.add(house)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加房屋成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;添加房屋失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除房屋</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delectHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========删除房屋==========&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入待删除房屋的编号(-1退出):&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">delectId</span> <span class="operator">=</span> Utility.readInt();</span><br><span class="line">        <span class="keyword">if</span> (delectId == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========放弃删除==========&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">choice</span> <span class="operator">=</span> Utility.readConfirmSelection();</span><br><span class="line">        System.out.println(choice);</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(houseService.delect(delectId)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========删除成功==========&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;==========房屋编号不存在==========&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========放弃删除==========&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找房屋</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========查找房屋信息==========&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要查找的id(1-6):&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">findId</span> <span class="operator">=</span> Utility.readInt();</span><br><span class="line">        <span class="type">House</span> <span class="variable">byId</span> <span class="operator">=</span> houseService.findById(findId);</span><br><span class="line">        <span class="keyword">if</span>(byId != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(byId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========id不存在==========&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 房屋修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========修改房屋信息==========&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;请选择带修改房屋编号(-1代表退出): &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">updateId</span> <span class="operator">=</span> Utility.readInt();</span><br><span class="line">        <span class="keyword">if</span>(updateId == -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========放弃修改============&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> houseService.findById(updateId);</span><br><span class="line">        <span class="keyword">if</span> (house == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========编号不存在===========&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;姓名(&quot;</span>+house.getName()+<span class="string">&quot;):&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Utility.readString(<span class="number">8</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(name)) &#123;</span><br><span class="line">            house.setName(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;电话(&quot;</span>+house.getPhone()+<span class="string">&quot;):&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> Utility.readString(<span class="number">8</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(phone)) &#123;</span><br><span class="line">            house.setPhone(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;地址(&quot;</span>+house.getAddress()+<span class="string">&quot;):&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> Utility.readString(<span class="number">8</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(address)) &#123;</span><br><span class="line">            house.setAddress(address);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;租金(&quot;</span>+house.getRent()+<span class="string">&quot;):&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rent</span> <span class="operator">=</span> Utility.readInt(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(rent != -<span class="number">1</span>) &#123;</span><br><span class="line">            house.setRent(rent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;状态(&quot;</span>+house.getState()+<span class="string">&quot;):&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> Utility.readString(<span class="number">8</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">&quot;&quot;</span>.equals(state)) &#123;</span><br><span class="line">            house.setName(state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==========修改成功==========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退出确认</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">choice</span> <span class="operator">=</span> Utility.readConfirmSelection();</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="string">&#x27;Y&#x27;</span>) &#123;</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="程序入口HouseRentApp"><a href="#程序入口HouseRentApp" class="headerlink" title="程序入口HouseRentApp"></a>程序入口HouseRentApp</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wlm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wlm.view.HouseView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseRentApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HouseView</span>().mainMenu();</span><br><span class="line">        System.out.println(<span class="string">&quot;您已经成功退出房屋出租系统~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="工具类Utils"><a href="#工具类Utils" class="headerlink" title="工具类Utils"></a>工具类Utils</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wlm.utils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	工具类的作用:</span></span><br><span class="line"><span class="comment">	处理各种情况的用户输入，并且能够按照程序员的需求，得到用户的控制台输入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line">	<span class="comment">//静态属性。。。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：读取键盘输入的一个菜单选项，值：1——5的范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 1——5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">readMenuSelection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">1</span>, <span class="literal">false</span>);<span class="comment">//包含一个字符的字符串</span></span><br><span class="line">            c = str.charAt(<span class="number">0</span>);<span class="comment">//将字符串转换成字符char类型</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27;1&#x27;</span> &amp;&amp; c != <span class="string">&#x27;2&#x27;</span> &amp;&amp; </span><br><span class="line">                c != <span class="string">&#x27;3&#x27;</span> &amp;&amp; c != <span class="string">&#x27;4&#x27;</span> &amp;&amp; c != <span class="string">&#x27;5&#x27;</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;选择错误，请重新输入：&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 功能：读取键盘输入的一个字符</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 一个字符</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">1</span>, <span class="literal">false</span>);<span class="comment">//就是一个字符</span></span><br><span class="line">        <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：读取键盘输入的一个字符，如果直接按回车，则返回指定的默认值；否则返回输入的那个字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultValue 指定的默认值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 默认值或输入的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">readChar</span><span class="params">(<span class="type">char</span> defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">1</span>, <span class="literal">true</span>);<span class="comment">//要么是空字符串，要么是一个字符</span></span><br><span class="line">        <span class="keyword">return</span> (str.length() == <span class="number">0</span>) ? defaultValue : str.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：读取键盘输入的整型，长度小于2位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">10</span>, <span class="literal">false</span>);<span class="comment">//一个整数，长度&lt;=10位</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                n = Integer.parseInt(str);<span class="comment">//将字符串转换成整数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;数字输入错误，请重新输入：&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：读取键盘输入的 整数或默认值，如果直接回车，则返回默认值，否则返回输入的整数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultValue 指定的默认值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整数或默认值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">(<span class="type">int</span> defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">10</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> defaultValue;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//异常处理...</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                n = Integer.parseInt(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;数字输入错误，请重新输入：&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：读取键盘输入的指定长度的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 限制的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定长度的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">(<span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readKeyBoard(limit, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：读取键盘输入的指定长度的字符串或默认值，如果直接回车，返回默认值，否则返回字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 限制的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultValue 指定的默认值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 指定长度的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">(<span class="type">int</span> limit, String defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(limit, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> str.equals(<span class="string">&quot;&quot;</span>)? defaultValue : str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 功能：读取键盘输入的确认选项，Y或N</span></span><br><span class="line"><span class="comment">	 * 将小的功能，封装到一个方法中.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Y或N</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">readConfirmSelection</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你的选择(Y/N): 请小心选择&quot;</span>);</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;<span class="comment">//无限循环</span></span><br><span class="line">        	<span class="comment">//在这里，将接受到字符，转成了大写字母</span></span><br><span class="line">        	<span class="comment">//y =&gt; Y n=&gt;N</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> readKeyBoard(<span class="number">1</span>, <span class="literal">false</span>).toUpperCase();</span><br><span class="line">            c = str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;Y&#x27;</span> || c == <span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;选择错误，请重新输入：&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能： 读取一个字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 读取的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> blankReturn 如果为true ,表示 可以读空字符串。 </span></span><br><span class="line"><span class="comment">     * 					  如果为false表示 不能读空字符串。</span></span><br><span class="line"><span class="comment">     * 			</span></span><br><span class="line"><span class="comment">	 *	如果输入为空，或者输入大于limit的长度，就会提示重新输入。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">readKeyBoard</span><span class="params">(<span class="type">int</span> limit, <span class="type">boolean</span> blankReturn)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//定义了字符串</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//scanner.hasNextLine() 判断有没有下一行</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            line = scanner.nextLine();<span class="comment">//读取这一行</span></span><br><span class="line">           </span><br><span class="line">			<span class="comment">//如果line.length=0, 即用户没有输入任何内容，直接回车</span></span><br><span class="line">			<span class="keyword">if</span> (line.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blankReturn) <span class="keyword">return</span> line;<span class="comment">//如果blankReturn=true,可以返回空串</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">continue</span>; <span class="comment">//如果blankReturn=false,不接受空串，必须输入内容</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果用户输入的内容大于了 limit，就提示重写输入  </span></span><br><span class="line">			<span class="comment">//如果用户如的内容 &gt;0 &lt;= limit ,我就接受</span></span><br><span class="line">            <span class="keyword">if</span> (line.length() &lt; <span class="number">1</span> || line.length() &gt; limit) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;输入长度（不能大于&quot;</span> + limit + <span class="string">&quot;）错误，请重新输入：&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
  <entry>
    <title>9. 类变量和类方法</title>
    <url>/2022/09/11/JavaSE/9.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(%E9%AB%98%E7%BA%A7)/</url>
    <content><![CDATA[<h1 id="9-1-类变量和类方法"><a href="#9-1-类变量和类方法" class="headerlink" title="9.1 类变量和类方法"></a>9.1 类变量和类方法</h1><h2 id="9-1-1-类变量"><a href="#9-1-1-类变量" class="headerlink" title="9.1.1 类变量"></a>9.1.1 类变量</h2><blockquote>
<p>类变量：也叫 静态变量&#x2F;静态属性。是该类所有对象共享的变量。任何一个该类对象访问时都是相同的值，任何一个该类对象修改时也是同一个变量。<br>语法（推荐）：<code>访问修饰符 static 数据类型 变量名;</code><br>或者也可以：<code>static 访问修饰符 数据类型 变量名;</code><br>根据 JDK 版本的不同，类变量存放在 堆 中或 方法区 中。</p>
</blockquote>
<ol>
<li>什么时候需要用类变量：当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</li>
<li>类变量 与 实例变量（普通属性）的区别：类变量 是该类所有对象共享的，而 实例变量 是每个对象独享的</li>
<li>加上 <code>static</code> 称为 类变量 或 静态变量。否则称为 实例变量&#x2F;普通变量&#x2F;非静态变量</li>
<li>静态变量 可以通过 <code>类名.类变量名;</code> 或 <code>对象名.类变量名;</code> 来访问。但 Java 设计者推荐我们用 <code>类名.类变量名;</code> 来访问。（需满足访问权限和范围）</li>
<li>类变量 是在加载类时就初始化了。所以，没有创建对象实例也能访问。</li>
<li>类变量 的生命周期是随着 类的加载 开始，随着 类的消亡 而销毁。</li>
<li>特别地：一<strong>个 null 对象也可以访问静态变量 &#x2F; 静态方法</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">met</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(++n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(t.n);			<span class="comment">//这样不会报错</span></span><br><span class="line">        t.met();							<span class="comment">//这样也不会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="9-1-2-类方法"><a href="#9-1-2-类方法" class="headerlink" title="9.1.2 类方法"></a>9.1.2 类方法</h2><blockquote>
<p>当方法使用 <code>static</code> 修饰后，就是 静态方法。静态方法就能访问静态属性。如果我们不希望创建实例，也能调用方法，这个场合把方法做成静态方法是合适的。开发工具类时就可以如此做。</p>
</blockquote>
<ol>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在 方法区。</li>
<li>类方法中不允许使用和对象有关的关键字。所以，类方法没有 this 或 super</li>
<li>类方法可以通过类名调用，也能通过对象名调用。普通方法不能通过类名调用。</li>
<li>类方法 中只能访问 类变量 或 类方法</li>
<li>普通方法既可以访问普通方法也可以访问类方法</li>
</ol>
<h1 id="9-2-理解-main-方法语法"><a href="#9-2-理解-main-方法语法" class="headerlink" title="9.2 理解 main 方法语法"></a>9.2 理解 <code>main</code> 方法语法</h1><blockquote>
<p><code>public static void main(String[] args)&#123;...&#125;</code></p>
</blockquote>
<ol>
<li><p><code>main</code> 方法 是 JVM 调用的方法。所以该方法的 访问权限 必须为 <code>public</code></p>
</li>
<li><p>JVM 在执行 <code>main</code> 方法时不必创建对象，所以 main方法 必须为 <code>static</code></p>
</li>
<li><p>该方法接收 <code>String</code> 类型的数组参数。该数组中保存执行 Java 命令 时传递给所运行的类的参数。</p>
<blockquote>
<p>工作台中：<code>javac 执行的程序.java</code><br><code>java 执行的程序 参数1(arg[0]) 参数2(arg[1]) 参数3(arg[2]) </code></p>
</blockquote>
</li>
<li><p>在 <code>main</code> 方法 中，我们可以直接调用 <code>main</code> 方法 所在类的静态方法或静态属性。但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例后才能通过该实例访问非静态成员</p>
</li>
</ol>
<h1 id="9-3-代码块"><a href="#9-3-代码块" class="headerlink" title="9.3 代码块"></a>9.3 代码块</h1><p>代码块：又称为 初始化块。属于类中的成员。类似于方法，将逻辑语句封装在方法体中，通过 { } 包围起来。和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类 显式调用，而是加载类时，或创建对象时 隐式调用。<br>语法：<code>[修饰符]&#123;代码&#125;;</code></p>
<ol>
<li>修饰符 是可选项，可不写。要写的话，只能写<code> static</code></li>
<li>代码块分为两类：<ul>
<li>静态代码块：有<code> static</code></li>
<li>普通代码块：无<code> static</code></li>
</ul>
</li>
<li>逻辑语句可以为任意的逻辑语句。</li>
<li><code>;</code> 可以写，也可以省略。建议写上。</li>
<li>代码块相当于另一种形式的构造器（构造器的补充机制），可以做初始化操作</li>
<li>如果多个构造器中都有重复语句，就可以抽取到初始化块中，提高代码复用率。这样，不管用哪个构造器，都会执行代码块。</li>
</ol>
<h2 id="9-3-1-使用细节"><a href="#9-3-1-使用细节" class="headerlink" title="9.3.1 使用细节"></a>9.3.1 使用细节</h2><ol>
<li><code>static</code> 代码块：作用是对类进行初始化。<strong>随着 类的加载 会且只会执行一次。</strong>相对的：普通代码块每创建一个对象就执行一次。</li>
</ol>
<ul>
<li><strong>类什么时候被加载？</strong><ul>
<li>创建对象实例时（new）</li>
<li>创建子类对象实例，父类也会加载</li>
<li>使用类的静态成员时（父类也会加载）</li>
</ul>
</li>
</ul>
<p>以上情况下类会被加载。加载后不需要再次加载，所以，静态代码块也只会执行一次。</p>
<ol start="2">
<li>创建一个对象时，在 <strong>一个类里</strong> 调用顺序是：<ul>
<li>调用静态代码块 和 静态属性初始化。这两者优先级相同，多个存在时按照定义的顺序依次执行。</li>
<li>调用普通代码块 和 普通属性初始化。这两者优先级也相同。</li>
<li>调用构造器。</li>
</ul>
</li>
<li><code>构造器</code> 的最前面其实隐含了 <code>super();</code> 和 <code>调用普通代码块</code>。而静态相关的代码块，属性初始化，在类加载时就执行完毕了。</li>
</ol>
<p>这样，创建一个对象时，在 <strong>有继承关系的多个类里</strong> 调用顺序是：</p>
<ul>
<li>父类 静态代码块 和 静态初始化</li>
<li>子类 静态代码块 和 静态初始化</li>
<li>父类 普通代码块 和 普通初始化</li>
<li>父类 构造器</li>
<li>子类 普通代码块 和 普通初始化</li>
<li>子类 构造器</li>
</ul>
<ol start="4">
<li>静态代码块 只能调用 静态成员。普通代码块 能调用 任意成员。</li>
</ol>
<h1 id="9-4-单例设计模式"><a href="#9-4-单例设计模式" class="headerlink" title="9.4 单例设计模式"></a>9.4 单例设计模式</h1><blockquote>
<p>什么是设计模式：设计模式是在大量的实践中总结和理论化后优选的代码结构、编程风格、解决问题的思考方式。设计模式就像是经典的棋谱，免去我们的再思考和摸索。</p>
</blockquote>
<p><strong>单例设计模式</strong>：采取一定的方法，保证再整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>
<h2 id="9-4-1-应用实例"><a href="#9-4-1-应用实例" class="headerlink" title="9.4.1 应用实例"></a>9.4.1 应用实例</h2><blockquote>
<p>后面会学的更多，这里展示两种：<strong>饿汉式</strong>、<strong>懒汉式</strong></p>
</blockquote>
<h3 id="9-4-1-1-饿汉式"><a href="#9-4-1-1-饿汉式" class="headerlink" title="9.4.1.1 饿汉式"></a>9.4.1.1 饿汉式</h3><p>步骤如下：</p>
<ol>
<li>构造器私有化（防止用户直接 new）</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GF</span>&#123;</span><br><span class="line">       <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GF</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GF</span>(<span class="string">&quot;萝茵&quot;</span>);</span><br><span class="line">       <span class="keyword">private</span> <span class="title function_">GF</span><span class="params">(String name)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.name = name;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> GF <span class="title function_">getGF</span><span class="params">()</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> gf;</span><br><span class="line">       &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对象，通常都是重量级的对象<br>有时，我们用不到这个创建的对象，那个场合，会造成资源浪费。</li>
</ol>
<h3 id="9-4-1-2-懒汉式"><a href="#9-4-1-2-懒汉式" class="headerlink" title="9.4.1.2 懒汉式"></a>9.4.1.2 懒汉式</h3><p>步骤如下：</p>
<ol>
<li>构造器私有化</li>
<li>定义一个静态属性对象</li>
<li>提供一个静态的公共方法，可以返回对象。如果静态对象为空，则创建对象</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">GF</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GF gf;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">GF</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> GF <span class="title function_">getGF</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(gf == <span class="literal">null</span>)&#123;</span><br><span class="line">          gf = <span class="keyword">new</span> <span class="title class_">GF</span>(<span class="string">&quot;萝茵&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> gf;</span><br><span class="line">  &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-4-1-3-两种方法对比"><a href="#9-4-1-3-两种方法对比" class="headerlink" title="9.4.1.3 两种方法对比"></a>9.4.1.3 两种方法对比</h3><ol>
<li>二者创建对象的时机不同。饿汉式在加载类信息时创建，懒汉式在使用时才创建</li>
<li>饿汉式可能造成资源浪费，懒汉式可能存在线程安全问题（学习[线程]后会进行完善）。</li>
<li>Java SE 标准类中 java.lang.Runtime 就是一个单例模式。</li>
</ol>
<h1 id="9-5-final关键字"><a href="#9-5-final关键字" class="headerlink" title="9.5 final关键字"></a>9.5 <code>final</code>关键字</h1><blockquote>
<p><code>final</code>可以修饰 类、属性、方法、局部变量<br>以下情况下，可能用到<code>final</code></p>
<ol>
<li><code>final</code> 修饰类：该类不能被继承</li>
<li><code>final</code> 修饰方法：该方法不能被重写</li>
<li><code>final</code> 修饰值：该值不能被修改</li>
</ol>
</blockquote>
<h2 id="9-5-1-使用细节"><a href="#9-5-1-使用细节" class="headerlink" title="9.5.1 使用细节"></a>9.5.1 使用细节</h2><ol>
<li><code>final</code> 修饰的属性又叫常量，一般用 XX_XX_XX 来命名（全大写字母+下划线）</li>
<li><code>final</code> 修饰的属性在定义时，必须赋初始值，且之后不能再修改。赋值可以在下列位置之一：<ul>
<li>定义时</li>
<li>构造器中</li>
<li>代码块中</li>
</ul>
</li>
</ol>
<p><strong>注意：如果 <code>final</code> 修饰的属性是静态的，则只能在以下位置赋值。</strong></p>
<ul>
<li>定义时</li>
<li>静态代码块中</li>
</ul>
<ol start="3">
<li><code>final</code> 类不能继承，但能实例化对象。对的，是可以的。</li>
<li>如果不是 <code>final</code> 类，但含有 <code>final</code> 方法，虽然该方法不能重写，但能被继承。</li>
<li><code>final</code> 类可以有 <code>final</code> 方法。可以，但没必要。</li>
<li><code>final</code> 不能修饰构造方法。</li>
<li><code>final</code> 和 <code>static</code> 搭配使用，效率更高（那个场合，虽然顺序不限，还是推荐 <code>static</code> 在前）。底层编译器做了优化处理。这样做，调用 属性（定义时赋值） 时居然 不会造成类的加载！</li>
<li>包装类（<code>Integer</code>、<code>Double</code>、<code>Float</code>、<code>Boolean</code>、<code>String</code>等）都是 <code>final</code> 类，都不能被继承。</li>
</ol>
<h1 id="9-6-抽象类"><a href="#9-6-抽象类" class="headerlink" title="9.6 抽象类"></a>9.6 抽象类</h1><blockquote>
<p>当父类的某些方法需要声明，却不知道如何实现时，可以将其声明为抽象方法。那个场合，要将该类声明为 <code>abstract</code> 类。抽象类的价值更多是用于设计。设计者设计好后，让子类继承并实现。也是考官爱问的考点。</p>
</blockquote>
<p>定义抽象类：<code>访问修饰符 abstract 类名&#123;...&#125;</code><br>定义抽象方法（注意：无方法体）：<code>访问修饰符 abstract 返回值 方法名(形参列表);</code></p>
<h2 id="9-6-1-使用细节"><a href="#9-6-1-使用细节" class="headerlink" title="9.6.1 使用细节"></a>9.6.1 使用细节</h2><ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定包含抽象方法。也就是说，抽象类可以没有 <code>abstract</code>方法</li>
<li>一旦包含 <code>abstract</code> 方法，则该类一定要声明为 <code>abstract</code></li>
<li><code>abstract</code> 只能修饰 类 和 方法，不能修饰其他。</li>
<li>抽象类可以有任意成员（非抽象方法、构造器、静态属性等）。即，抽象类本质还是类。</li>
<li>抽象方法不能有主体。即，抽象方法不能实现。</li>
<li>如果一个类继承了 <code>abstract</code> 类，则其必须实现所有 <code>abstract</code> 方法，除非其自己也是 <code>abstract</code> 类。</li>
<li>抽象方法不能用 <code>private</code> <code>final</code> <code>static</code> 来修饰。因为，这些关键词都和 重写 相违背。</li>
</ol>
<h1 id="9-7-接口"><a href="#9-7-接口" class="headerlink" title="9.7 接口"></a>9.7 接口</h1><blockquote>
<p>接口就是给出一些没有实现的方法，封装到一起，到某个类要用的时候，再根据具体情况把这些方法写出来。<br>语法：<code>interface 接口名&#123;...&#125;</code><br><code>class 类名 implements 接口名&#123;...必须实现接口的抽象方法...&#125;</code><br>注意：JDK 7.0 以前，接口中只能是抽象方法。而 JDK 8.0 后，接口可以有静态（<code>static</code>）方法、默认（<code>default</code>）方法。在接口中，抽象方法可以省略 <code>abstract</code></p>
</blockquote>
<p>接口中可以存在：</p>
<ul>
<li>属性（只有静态 <code>static</code> 属性，可以不加 <code>static</code> 关键字）</li>
<li>方法（抽象 <code>abstract</code> 方法、默认 <code>default</code> 实现方法、静态 <code>static</code> 方法）</li>
</ul>
<h2 id="9-7-1-使用细节"><a href="#9-7-1-使用细节" class="headerlink" title="9.7.1 使用细节"></a>9.7.1 使用细节</h2><ol>
<li>接口 不能被实例化。</li>
<li>接口中所有方法都是 <code>public</code> 方法。接口中的 抽象方法 可以不用 <code>abstract</code> 修饰。</li>
<li>一个普通类实现接口，就必须把该接口所有方法都实现。（用快捷键吧 <code>alt + enter</code>）</li>
<li>抽象类实现接口，可以不用实现接口的方法。</li>
<li>一个类可以同时实现多个接口。<code>class Name implements In1,In2&#123;...&#125;</code></li>
<li>接口中的属性只能是 <code>final</code> 的，并且是 <code>public static final</code> 修饰符。修饰符就算不写，还是这样。</li>
<li>接口中属性的访问形式：<code>接口名.属性名</code></li>
<li>接口不能 <strong>继承</strong> 其他的类，但可以 <strong>继承</strong> <strong>多个</strong>别的接口。（不是也不能 实现 别的接口）</li>
<li>接口的修饰符只能是 <code>public</code> 和 默认。这点和类的修饰符相同。</li>
</ol>
<h2 id="9-7-2-实现接口-vs-继承类"><a href="#9-7-2-实现接口-vs-继承类" class="headerlink" title="9.7.2 实现接口 vs 继承类"></a>9.7.2 实现接口 vs 继承类</h2><ol>
<li>当子类继承父类，就自动拥有父类的所有功能。如果需要扩展功能，可以通过接口方式扩展。</li>
<li>可以认为，接口 是对于 Java 单继承机制的补充。</li>
<li>继承的价值主要在于：解决代码的复用性和可维护性。</li>
<li>接口的价值主要在于：设计。设计好各种规范，让其他类去实现这些方法。</li>
<li>接口比继承更加灵活。继承需要满足 is - a 的关系，而接口只需要满足 like - a 关系。</li>
<li>接口在一定程度上实现代码解耦。（即：接口规范性 + 动态绑定机制）</li>
</ol>
<h2 id="9-7-3-接口的多态特性"><a href="#9-7-3-接口的多态特性" class="headerlink" title="9.7.3 接口的多态特性"></a>9.7.3 接口的多态特性</h2><ol>
<li><p>多态参数（接口的引用可以指向实现了接口的类的对象）</p>
<blockquote>
<p><code>viod work(Inerface01 i1)&#123;...&#125;</code> 参数可以传入任意实现该接口的类</p>
</blockquote>
</li>
<li><p>多态数组</p>
</li>
<li><p>接口存在多态传递现象</p>
</li>
</ol>
<h1 id="9-8-内部类"><a href="#9-8-内部类" class="headerlink" title="9.8 内部类"></a>9.8 内部类</h1><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为 内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;		<span class="comment">//外部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;	<span class="comment">//内部类	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;		<span class="comment">//外部其他类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p>
<h2 id="9-8-1-四种内部类"><a href="#9-8-1-四种内部类" class="headerlink" title="9.8.1 四种内部类"></a>9.8.1 四种内部类</h2><p>分别是：</p>
<ul>
<li>定义在外部类的局部位置上<ul>
<li>局部内部类：有 类名</li>
<li><strong>匿名内部类：无 类名</strong></li>
</ul>
</li>
<li>定义在外部类的成员位置上<ul>
<li>成员内部类：无 <code>static</code> 修饰</li>
<li>静态内部类： <code>static</code> 修饰的类</li>
</ul>
</li>
</ul>
<h2 id="9-8-2-局部内部类"><a href="#9-8-2-局部内部类" class="headerlink" title="9.8.2 局部内部类"></a>9.8.2 局部内部类</h2><p>局部内部类：定义在外部类的局部位置上，并且有类名。（局部位置？比如：方法&#x2F;代码块里）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;				<span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tools01</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;		<span class="comment">//局部内部类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-8-2-1-使用细节"><a href="#9-8-2-1-使用细节" class="headerlink" title="9.8.2.1 使用细节"></a>9.8.2.1 使用细节</h3><ol>
<li><p>定义在外部类的局部位置上，并且有类名。</p>
</li>
<li><p>可以访问外部类的所有成员，包含私有成员</p>
</li>
<li><p>局部内部类可以 直接访问 外部类的成员。</p>
</li>
<li><p>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></p>
</li>
<li><p>作用域 仅仅在定义它的方法或代码块中</p>
</li>
<li><p>外部类 在方法中，可以创建 局部内部类 的对象实例，然后调用方法。</p>
</li>
<li><p>外部其他类 不能访问 局部内部类</p>
</li>
<li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></p>
<pre><code>`外部类名.this` 本质就是 **外部类**的对象。即，调用了该方法（上例的 `tools01` ）的对象
</code></pre>
</li>
</ol>
<h2 id="9-8-3-匿名内部类"><a href="#9-8-3-匿名内部类" class="headerlink" title="9.8.3 匿名内部类"></a>9.8.3 匿名内部类</h2><p>匿名内部类：定义在外部类的局部位置，且没有类名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类/接口 (参数列表) &#123;</span><br><span class="line">   类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名内部类本质是没有名字的类，而且是内部类。同时，还是一个对象。<br>可以用匿名内部类简化开发<br>一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;							<span class="comment">//外部类</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tools01</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Inter</span> <span class="variable">whatEver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inter</span>()&#123;	<span class="comment">//匿名内部类            </span></span><br><span class="line">       &#125;;						</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，这个匿名内部类 <code>new Inter()&#123;&#125;</code> 的运行类型就是 <code>class XXXX implements Inter</code>。系统自动分配的名字是 <code>Outer$1</code>（<code>whatEver.getClass = &quot;Outer$1&quot;</code>)<br>JDK 在创建匿名内部类<code> Outer$1</code> 时，立即创建了一个对象实例，并将地址返回给了 <code>whatEver</code><br>匿名内部类使用一次后就不能再次使用（<code>Outer$1</code> 就这一个了）</p>
<h3 id="9-8-3-1-使用细节"><a href="#9-8-3-1-使用细节" class="headerlink" title="9.8.3.1 使用细节"></a>9.8.3.1 使用细节</h3><ol>
<li>匿名内部类语法比较独特。其既是一个类的定义，也是一个对象。因此，从语法上看，其既有 定义类的特征，也有 创建对象的特征。</li>
<li>可以访问外部类的所有成员，包括私有的。</li>
<li>局部内部类可以 直接访问 外部类的成员。</li>
<li>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></li>
<li>作用域：仅仅在定义它的方法或方法快中</li>
<li>外部其他类 不能访问 匿名内部类</li>
<li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li>
</ol>
<h3 id="9-8-3-2-使用场景"><a href="#9-8-3-2-使用场景" class="headerlink" title="9.8.3.2 使用场景"></a>9.8.3.2 使用场景</h3><ol>
<li>当作实参直接传递，简洁高效<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Homework1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;		</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cellphone</span>().clock(<span class="keyword">new</span> <span class="title class_">Bell</span>() &#123;				<span class="comment">//看这里看这里</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">belling</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;testDemo！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bell</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">ringing</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cellphone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clock</span><span class="params">(Bell bell)</span>&#123;</span><br><span class="line">        bell.ringing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="9-8-4-成员内部类"><a href="#9-8-4-成员内部类" class="headerlink" title="9.8.4 成员内部类"></a>9.8.4 成员内部类</h2><p>成员内部类：定义在外部类的成员位置，并且没有 <code>static</code> 修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-8-4-1-使用细节"><a href="#9-8-4-1-使用细节" class="headerlink" title="9.8.4.1 使用细节"></a>9.8.4.1 使用细节</h3><ol>
<li>可以直接访问外部类的所有成员，包括私有的</li>
<li>可以添加任意访问修饰符。因为，成员内部类的地位就是一个成员。</li>
<li>作用域 和外部类其他成员相同，为整个类体。</li>
<li>局部内部类可以 直接访问 外部类的成员。</li>
<li>外部类可以通过创建对象的方式访问成员内部类</li>
<li>外部其他类访问成员内部类<ul>
<li><code>Outer.Inner name = Outer.new Inner();</code> 下个方法的缩写</li>
<li><code>Outer.Inner name = new Outer().new Inner();</code></li>
<li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例（就是对象的 getter）</li>
</ul>
</li>
<li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li>
</ol>
<h2 id="9-8-5-静态内部类"><a href="#9-8-5-静态内部类" class="headerlink" title="9.8.5 静态内部类"></a>9.8.5 静态内部类</h2><p>静态内部类：定义在外部类的成员位置，经由 <code>static</code> 修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-8-5-1-使用细节"><a href="#9-8-5-1-使用细节" class="headerlink" title="9.8.5.1 使用细节"></a>9.8.5.1 使用细节</h3><ol>
<li>可以直接访问外部类的所有 <strong>静态</strong> 成员，包括私有的。但不能访问非静态成员</li>
<li>可以添加访问修饰符。因为，静态内部类的地位就是一个成员。</li>
<li>作用域 和其他成员相同，为整个类体。</li>
<li>静态内部类可以 直接访问 外部类的成员。</li>
<li>外部类可以通过创建对象的方式访问静态内部类</li>
<li>外部其他类访问静态内部类<ul>
<li><code>Outer.Inner name = new Outer.Inner();</code> 即通过类名直接访问</li>
<li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例</li>
<li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.变量名</code>。（怎么不一样了呢？因为静态内部类访问的都是静态成员）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java 学习</category>
        <category>JavaSE (韩顺平)</category>
      </categories>
      <tags>
        <tag>Java 学习</tag>
        <tag>JavaSE</tag>
        <tag>韩顺平基础</tag>
      </tags>
  </entry>
</search>
